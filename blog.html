<!doctype html>
<html lang="zh-CN" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">Blog | AutoDev - Tailor Your AI Coding Experience</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://ide.unitmesh.cc/blog"><meta data-rh="true" property="og:locale" content="zh_CN"><meta data-rh="true" property="og:locale:alternate" content="en_US"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="Blog | AutoDev - Tailor Your AI Coding Experience"><meta data-rh="true" name="description" content="Blog"><meta data-rh="true" property="og:description" content="Blog"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://ide.unitmesh.cc/blog"><link data-rh="true" rel="alternate" href="https://ide.unitmesh.cc/en/blog" hreflang="en-US"><link data-rh="true" rel="alternate" href="https://ide.unitmesh.cc/blog" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="https://ide.unitmesh.cc/blog" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"Blog","@id":"https://ide.unitmesh.cc/blog","mainEntityOfPage":"https://ide.unitmesh.cc/blog","headline":"Blog","description":"Blog","blogPost":[{"@type":"BlogPosting","@id":"https://ide.unitmesh.cc/blog/autodev-3-poc","mainEntityOfPage":"https://ide.unitmesh.cc/blog/autodev-3-poc","url":"https://ide.unitmesh.cc/blog/autodev-3-poc","headline":"AutoDev 架构升级：多端（CLI/Desktop/Mobile）编程 Agent，欢迎一起参与演进","name":"AutoDev 架构升级：多端（CLI/Desktop/Mobile）编程 Agent，欢迎一起参与演进","description":"半年前，我在《AutoDev Next》那篇文章中介绍了 AutoDev 的下一代架构，其中一个核心方向就是：多端支持。","datePublished":"2025-11-10T08:47:31.000Z","author":[],"keywords":[]},{"@type":"BlogPosting","@id":"https://ide.unitmesh.cc/blog/2025/04/25/autodev-local-agent","mainEntityOfPage":"https://ide.unitmesh.cc/blog/2025/04/25/autodev-local-agent","url":"https://ide.unitmesh.cc/blog/2025/04/25/autodev-local-agent","headline":"AutoDev 本地智能体，你的 Agent 自由工坊","name":"AutoDev 本地智能体，你的 Agent 自由工坊","description":"当下大多数 AI 编程助手，无论是 Copilot、Cursor，还是各种类 AutoGPT 项目，本质上都存在一个问题：AI 编码助手只是更强的补全器，","datePublished":"2025-04-25T00:00:00.000Z","author":[],"keywords":[]},{"@type":"BlogPosting","@id":"https://ide.unitmesh.cc/blog/2025/03/26/autodev-2-0","mainEntityOfPage":"https://ide.unitmesh.cc/blog/2025/03/26/autodev-2-0","url":"https://ide.unitmesh.cc/blog/2025/03/26/autodev-2-0","headline":"AutoDev 2.0 正式发布！智能体 x 开源生态 = 无限可能","name":"AutoDev 2.0 正式发布！智能体 x 开源生态 = 无限可能","description":"PS：在我们等待了几个月之后，国内终于有模型（DS V3-0324）能支持 AutoDev 的能力，也因此是时候发布 AutoDev 2.0 了！","datePublished":"2025-03-26T00:00:00.000Z","author":[],"keywords":[]},{"@type":"BlogPosting","@id":"https://ide.unitmesh.cc/blog/2025/03/18/autodev-planner","mainEntityOfPage":"https://ide.unitmesh.cc/blog/2025/03/18/autodev-planner","url":"https://ide.unitmesh.cc/blog/2025/03/18/autodev-planner","headline":"AutoDev Planner","name":"AutoDev Planner","description":"最近，我们在 AutoDev 上构建了新的功能：AutoDev Planner，它是一个基于 DeepSeek R1 推理模型构建的编码任务规划功能。当然了，除了 DeepSeek","datePublished":"2025-03-18T00:00:00.000Z","author":[],"keywords":[]},{"@type":"BlogPosting","@id":"https://ide.unitmesh.cc/blog/2025/03/12/autodev-mcp","mainEntityOfPage":"https://ide.unitmesh.cc/blog/2025/03/12/autodev-mcp","url":"https://ide.unitmesh.cc/blog/2025/03/12/autodev-mcp","headline":"AutoDev MCP","name":"AutoDev MCP","description":"在 Agentic Coding 这一话题下，工具使用（Tool Use/Function calling）是一个非常有意思的话题。完成一个软件开发任务，需要使用到大量的工具，","datePublished":"2025-03-12T00:00:00.000Z","author":[],"keywords":[]},{"@type":"BlogPosting","@id":"https://ide.unitmesh.cc/blog/2025/03/06/autodev-bridge","mainEntityOfPage":"https://ide.unitmesh.cc/blog/2025/03/06/autodev-bridge","url":"https://ide.unitmesh.cc/blog/2025/03/06/autodev-bridge","headline":"AutoDev Bridge","name":"AutoDev Bridge","description":"在 2023 年，基于当时的模型能力有限，我们在 AutoDev 设计了一系列的遗留系统功能的特性。而在 2025 年，经过自动编程智能体","datePublished":"2025-03-06T00:00:00.000Z","author":[],"keywords":[]},{"@type":"BlogPosting","@id":"https://ide.unitmesh.cc/blog/2025/01/11/autodev-2-0-preview","mainEntityOfPage":"https://ide.unitmesh.cc/blog/2025/01/11/autodev-2-0-preview","url":"https://ide.unitmesh.cc/blog/2025/01/11/autodev-2-0-preview","headline":"AutoDev Composer the Intellij IDEA Cursor Alternative","name":"AutoDev Composer the Intellij IDEA Cursor Alternative","description":"A little over two weeks ago, after the release of DeepSeek V3, we introduced multi-file editing capabilities for Shire.","datePublished":"2025-01-11T00:00:00.000Z","author":[],"keywords":[]},{"@type":"BlogPosting","@id":"https://ide.unitmesh.cc/blog/2024/03/17/autodev-devins-language","mainEntityOfPage":"https://ide.unitmesh.cc/blog/2024/03/17/autodev-devins-language","url":"https://ide.unitmesh.cc/blog/2024/03/17/autodev-devins-language","headline":"Agent Language - DevIns","name":"Agent Language - DevIns","description":"在上一个版本中，我们构建了 AutoDev 的自定义 Agent 功能，即用户可以通过自定义能力来构建自己的智能体，以实现对于软件开发任务的智能辅助。","datePublished":"2024-03-17T00:00:00.000Z","author":[],"keywords":[]},{"@type":"BlogPosting","@id":"https://ide.unitmesh.cc/blog/2024/03/07/autodev-1-7-0","mainEntityOfPage":"https://ide.unitmesh.cc/blog/2024/03/07/autodev-1-7-0","url":"https://ide.unitmesh.cc/blog/2024/03/07/autodev-1-7-0","headline":"AutoDev 1.7.0 AutoDev AI Agent","name":"AutoDev 1.7.0 AutoDev AI Agent","description":"在开源 AI IDE 插件 AutoDev 的  #51 issue 中，我们设计了 AutoDev 的 AI","datePublished":"2024-03-07T00:00:00.000Z","author":[],"keywords":[]},{"@type":"BlogPosting","@id":"https://ide.unitmesh.cc/blog/2024/02/25/autodev-1-6-4","mainEntityOfPage":"https://ide.unitmesh.cc/blog/2024/02/25/autodev-1-6-4","url":"https://ide.unitmesh.cc/blog/2024/02/25/autodev-1-6-4","headline":"AutoDev 1.6.4 HarmonyOS 应用开发体验提升","name":"AutoDev 1.6.4 HarmonyOS 应用开发体验提升","description":"生成式 AI 在软件研发和知识管理上，有着非常大的潜力，也因此这项技术被越来越多的企业所采用。而在一些新兴的技术上，诸如于鸿蒙操作系统，它带来了一些新","datePublished":"2024-02-25T00:00:00.000Z","author":[],"keywords":[]}]}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="AutoDev - Tailor Your AI Coding Experience RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="AutoDev - Tailor Your AI Coding Experience Atom Feed"><link rel="stylesheet" href="/assets/css/styles.e0fdecde.css">
<script src="/assets/js/runtime~main.db478b25.js" defer="defer"></script>
<script src="/assets/js/main.bbbf607e.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/img/logo.svg"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="AutoDev 标志" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="AutoDev 标志" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">AutoDev</b></a><a class="navbar__item navbar__link" href="/intro">文档</a><a class="navbar__item navbar__link" href="/customize">Customize</a><a class="navbar__item navbar__link" href="/agent">Agent</a><a class="navbar__item navbar__link" href="/mpp/autodev-multiplatform">MultiPlatform</a><a class="navbar__item navbar__link" href="/ai-friendly">AI Friendly</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">博客</a><a class="navbar__item navbar__link" href="/development">Development</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>简体中文</a><ul class="dropdown__menu"><li><a href="/en/blog" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en-US">English</a></li><li><a href="/blog" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="zh-CN">简体中文</a></li></ul></div><a href="https://github.com/unit-mesh/auto-dev" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><div role="group"><h3 class="yearGroupHeading_rMGB">2025</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/autodev-3-poc">AutoDev 架构升级：多端（CLI/Desktop/Mobile）编程 Agent，欢迎一起参与演进</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2025/04/25/autodev-local-agent">AutoDev 本地智能体，你的 Agent 自由工坊</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2025/03/26/autodev-2-0">AutoDev 2.0 正式发布！智能体 x 开源生态 = 无限可能</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2025/03/18/autodev-planner">AutoDev Planner</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2025/03/12/autodev-mcp">AutoDev MCP</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2025/03/06/autodev-bridge">AutoDev Bridge</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2025/01/11/autodev-2-0-preview">AutoDev Composer the Intellij IDEA Cursor Alternative</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2024</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2024/03/17/autodev-devins-language">Agent Language - DevIns</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2024/03/07/autodev-1-7-0">AutoDev 1.7.0 AutoDev AI Agent</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2024/02/25/autodev-1-6-4">AutoDev 1.6.4 HarmonyOS 应用开发体验提升</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2024/01/26/autodev-1-6-0">AutoDev 1.6.0 精准页面生成与 SQL 生成</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2024/01/12/autodev-1-5-3">AutoDev 1.5.3 精准测试生成</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/autodev-coder">AutoDev Coder</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2023</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/10/22/autodev-1-4-0">AutoDev 1.4 规模化 AI 研发辅助</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/autodev-1-0-0">AutoDev 1.0 发布，全流程 AI 辅助编程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/autodev-0-7-0">AutoDev 0.7.0 - 生成规范化代码，深入开发者日常</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/04/18/autodev">AutoDev：AI 突破研发效能，探索平台工程新机遇</a></li></ul></div></nav></aside><main class="col col--7"><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/autodev-3-poc">AutoDev 架构升级：多端（CLI/Desktop/Mobile）编程 Agent，欢迎一起参与演进</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2025-11-10T08:47:31.000Z">2025年11月10日</time> · <!-- -->阅读需 7 分钟</div></header><div class="markdown"><p>半年前，我在《AutoDev Next》那篇文章中介绍了 AutoDev 的下一代架构，其中一个核心方向就是：<strong>多端支持</strong>。
之后，一直在忙项目交付——从 AI 参与遗留系统现代化，到做 AI 辅助的软件工程培训。一直到国庆，才终于有整块时间继续推进 AutoDev
的演进。</p>
<p>这段时间里，我不断做 POC，验证不同技术模型的可行性，尝试新的交互与架构思路。直到最近，新的重构方向基本成型，并成功跑通了关键链路，也顺手
Vibe Coding 了一波。</p>
<p>TL;DR：代码：<a href="https://github.com/unit-mesh/auto-dev" target="_blank" rel="noopener noreferrer">https://github.com/unit-mesh/auto-dev</a> （似乎是目前国内最好的开源 AI 编程工具）</p>
<p><img decoding="async" loading="lazy" src="/assets/images/autodev-github-3318284894a4351ca8794a805bf2e40a.png" width="2516" height="940" class="img_ev3q"></p>
<p>欢迎来一起加入演进。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="基于-kmp--compose-的-autodev-多平台重构实践">基于 KMP + Compose 的 AutoDev 多平台重构实践<a href="#基于-kmp--compose-的-autodev-多平台重构实践" class="hash-link" aria-label="基于 KMP + Compose 的 AutoDev 多平台重构实践的直接链接" title="基于 KMP + Compose 的 AutoDev 多平台重构实践的直接链接">​</a></h2>
<p>新的 AutoDev 架构如下：</p>
<p><img decoding="async" loading="lazy" alt="新 AutoDev 架构" src="/assets/images/autodev-next-arch-a78eedadb989dd698670093152b6c9f4.png" width="2324" height="1142" class="img_ev3q"></p>
<blockquote>
<p>PS：之所以叫重构，是我们在 AutoDev 上已经有大量的经验，尽管架构上是紧耦合的，但是利于 AI 阅读后重写，比如，我们的 DevIns 语言。
在这几个月里，我也尝试使用 Rust/TypeScript/Kotlin 来开发的 CLI，但是发现多数时间在写之前的重复性代码。所以，基于 KMP
（Kotlin Multiplatform）是一个更合理的架构。</p>
</blockquote>
<p>在新的架构里，MPP-Core 是我们的核心，基于 Kotlin 的 Multiplatform 技术，我们构建出了 JS 和 JVM 版本的两个核心接口和实现，基于
这两个实现。基于多平台的 Core + Compose UI，我们就可以构建出：</p>
<ul>
<li>基于 JS 版本的 <code>@autodev/cli</code> 的 CLI （Command Line Interface）和 TUI （Terminal UI）版本</li>
<li>基于 JVM 版本的 AutoDev IDEA，AutoDev Desktop 和 AutoDev Android，以及未来的 AutoDev iOS</li>
</ul>
<p>而为了在当前 AI Token 还不便宜、Agent grep 还不理想的情况下，我们还是构建了基于 TreeSitter 的 MPP-CodeGraph，通过树和图的方式
来节省上下文，近而节省企业的成本。Codex、Gemini CLI、Claude Code 都是 AI 厂商卖 token 的，自然可以不考虑那么多。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="codegraph基于树和代码图的上下文压缩引擎">CodeGraph：基于树和代码图的上下文压缩引擎<a href="#codegraph基于树和代码图的上下文压缩引擎" class="hash-link" aria-label="CodeGraph：基于树和代码图的上下文压缩引擎的直接链接" title="CodeGraph：基于树和代码图的上下文压缩引擎的直接链接">​</a></h3>
<p>尽管 Gemini CLI 和 Claude Code 提供了近似无限上下文的能力，但是对于重构等一系列复杂问题的分析，它们依然非常不靠谱，而且非常贵。
所以，我们还是要引入 CodeGraph 来解决复杂问题下的代码搜索等问题。而 TreeSitter 是目标 “跨平台” 最好的方式之一，毕竟 wasm + binary
可以运行在各种平台上。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="autodev-idea核心能力即-mcp-能力">AutoDev IDEA：核心能力即 MCP 能力<a href="#autodev-idea核心能力即-mcp-能力" class="hash-link" aria-label="AutoDev IDEA：核心能力即 MCP 能力的直接链接" title="AutoDev IDEA：核心能力即 MCP 能力的直接链接">​</a></h3>
<p>在新版本的 IDEA 里，MCP 已经是内置的能力，而我们还是预期 AutoDev 作为 MCP 服务端，来为其它的 Agent 提供服务。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么是-autodev-desktop-和-autodev-android-">为什么是 AutoDev Desktop 和 AutoDev Android ？<a href="#为什么是-autodev-desktop-和-autodev-android-" class="hash-link" aria-label="为什么是 AutoDev Desktop 和 AutoDev Android ？的直接链接" title="为什么是 AutoDev Desktop 和 AutoDev Android ？的直接链接">​</a></h3>
<p>半年前，我一直在思考如果做一个新 AI IDE 我们是否需要语法高亮，是否需要代码跳转，AutoDev 是不是优势会越来越小。直到，最近的新版本的
Cursor 给出了一个答案，独立 UI 下的 Agents 模式。在简单的任务下，我们并不需要一直坐在电脑前面，比如我在 iPad 上用 VNC Viewer
来看电脑上的进度， 并可以一边看娃。</p>
<p>既然如此，Android 和 iOS 版本就更有意义了，你可以从踏上地铁、公交车的时候，就可以远程 Vibe Coding。然后到了公司，就可以美滋滋地去
<del>吃个早饭</del>（修 AI 的 bug）。</p>
<p><img decoding="async" loading="lazy" src="/assets/images/autodev-android-415c56e4439797ac8d487b8b8199344c.jpg" width="1440" height="3200" class="img_ev3q"></p>
<p>毕竟，Android 上可不写不了代码。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="用-compose-重塑-autodev-的界面与交互">用 Compose 重塑 AutoDev 的界面与交互<a href="#用-compose-重塑-autodev-的界面与交互" class="hash-link" aria-label="用 Compose 重塑 AutoDev 的界面与交互的直接链接" title="用 Compose 重塑 AutoDev 的界面与交互的直接链接">​</a></h2>
<p>在几个月前，在和 @iptton 尝试使用 Intellij Compose 构建了一个新的 AutoDev IDE UI 之后，
我也尝试了在 2025.2 的版本 IDEA 上 Vibe Coding 了一个新的 UI。显然，与 Swing 相比，有大量语料的 Compose 表现得更加稳定和可靠，不会
像 Swing 报一堆错误。</p>
<p><img decoding="async" loading="lazy" src="/assets/images/autodev-desktop-d434669036711a040073305c91f4c269.png" width="2400" height="1600" class="img_ev3q"></p>
<p>既然，我们有了更好的 Vibe Coding，那传统的 IDE 交互方式是不是就不需要了，非专业人士只需要一个聊天界面，以及可以实时预览和交互的
UI 就行了？</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="mpp-coreautodev-的跨平台核心引擎">MPP-Core：AutoDev 的跨平台核心引擎<a href="#mpp-coreautodev-的跨平台核心引擎" class="hash-link" aria-label="MPP-Core：AutoDev 的跨平台核心引擎的直接链接" title="MPP-Core：AutoDev 的跨平台核心引擎的直接链接">​</a></h2>
<p>如下是我们去年的 AutoDev 架构图，你可以看到在不同平台（JetBrains、VSCode）上的架构差异：</p>
<p><img decoding="async" loading="lazy" alt="autodev-jetbrains-vscode.png" src="/assets/images/autodev-jetbrains-vscode-c97762f5feb5604099af38c702f5c05b.png" width="2710" height="1420" class="img_ev3q"></p>
<p>而在今天来看，尽管架构发生了巨大的变化，一切都围绕着 Tool 和 Agent：</p>
<p><img decoding="async" loading="lazy" alt="Coding Agent" src="/assets/images/simple-coding-agents-09fc32422e931b3871cbddacde6c6569.png" width="2702" height="1272" class="img_ev3q"></p>
<p>我们可以通过 Tool 接口和抽象很好地剥离平台间的差异，进而把各种能力都放在 core 上，进而更好地实现跨平台能力：</p>
<p><img decoding="async" loading="lazy" alt="AutoDev CLI" src="/assets/images/autodev-cli-21bb077a9d9fa95fd99672bf97ec0196.png" width="1488" height="612" class="img_ev3q"></p>
<p>近而，我们就可以构建出如上图所示的 AutoDev CLI。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="欢迎加入-autodev-的多端编程世界">欢迎加入 AutoDev 的多端编程世界<a href="#欢迎加入-autodev-的多端编程世界" class="hash-link" aria-label="欢迎加入 AutoDev 的多端编程世界的直接链接" title="欢迎加入 AutoDev 的多端编程世界的直接链接">​</a></h2>
<p>作为一个刚完成 POC 的版本，我们依然有大量的工作要做。</p>
<p>如果你对 AI 编程、跨平台 Agent、或者像 AutoDev 这样前沿的多端架构感兴趣，无论你是开发者、研究者，还是想玩玩 Vibe Coding
的爱好者，都欢迎加入我们！</p>
<p>我们在 GitHub 上持续更新代码、分享实践经验，也期待你的反馈、PR、甚至新点子——让 AutoDev 的多平台之路走得更稳、更远。</p></div><footer class="row docusaurus-mt-lg"></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/2025/04/25/autodev-local-agent">AutoDev 本地智能体，你的 Agent 自由工坊</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2025-04-25T00:00:00.000Z">2025年4月25日</time> · <!-- -->阅读需 6 分钟</div></header><div class="markdown"><p>当下大多数 AI 编程助手，无论是 Copilot、Cursor，还是各种类 AutoGPT 项目，本质上都存在一个问题：AI 编码助手只是更强的补全器，
而不是具备行为能力的开发者副手。它们擅长补全代码，但缺乏结构化任务理解、缺乏上下文感知，更无法根据开发者的意图自我组织多步行为。
更重要的是：<strong>它们是“别人造好的助手，而不是你能定义的工具</strong></p>
<p>AutoDev 的本地智能体系统，从根本上改变了这个逻辑。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="autodev-的新范式prompt-即-agent配置即能力链">AutoDev 的新范式：Prompt 即 Agent，配置即能力链<a href="#autodev-的新范式prompt-即-agent配置即能力链" class="hash-link" aria-label="AutoDev 的新范式：Prompt 即 Agent，配置即能力链的直接链接" title="AutoDev 的新范式：Prompt 即 Agent，配置即能力链的直接链接">​</a></h2>
<p>AutoDev 推出的本地智能体系统以两个核心理念为基础：</p>
<ol>
<li><strong>智能体的结构可声明、能力可组合、行为可扩展</strong></li>
<li><strong>一句 Prompt + 一段配置，生成一个完全私有、本地可运行的 Agent 编码助手</strong></li>
</ol>
<p>其核心架构允许开发者：</p>
<ul>
<li>自定义 agent 的能力链（例如先读文件、再检索相关函数、然后写测试并提交）</li>
<li>注入自己的提示词风格、子任务规划逻辑，甚至嵌入插件模块</li>
<li>在本地选择任意大模型（如 Deepseek、Qwen、GLM）完成推理</li>
</ul>
<p>你还可以定义它在 IDE 的交互方式、在命令行的交互方式，甚至在 @ 的交互方式：</p>
<ul>
<li>actionLocation：IDE 中的交互位置，诸如 ContextMenu、CommitMenu、@mention 等</li>
<li>interaction：输出方式，诸如 AppendCursor、RightPanel 等。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-示例配置一分钟声明你的-agent">✅ 示例配置：一分钟声明你的 Agent<a href="#-示例配置一分钟声明你的-agent" class="hash-link" aria-label="✅ 示例配置：一分钟声明你的 Agent的直接链接" title="✅ 示例配置：一分钟声明你的 Agent的直接链接">​</a></h3>
<p>如下，我们将创建一个用户选中需求后，可以用鼠标右键点击生成 Protobuf IDL 的智能体：</p>
<div class="language-devin codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-devin codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token front-matter-block punctuation" style="color:#393A34">---</span><span class="token front-matter-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block"></span><span class="token front-matter-block front-matter yaml language-yaml key atrule" style="color:#00a4db">name</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">:</span><span class="token front-matter-block front-matter yaml language-yaml"> </span><span class="token front-matter-block front-matter yaml language-yaml string" style="color:#e3116c">&quot;Design Profobuf IDL&quot;</span><span class="token front-matter-block front-matter yaml language-yaml"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block front-matter yaml language-yaml"></span><span class="token front-matter-block front-matter yaml language-yaml key atrule" style="color:#00a4db">actionLocation</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">:</span><span class="token front-matter-block front-matter yaml language-yaml"> ContextMenu</span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block front-matter yaml language-yaml"></span><span class="token front-matter-block front-matter yaml language-yaml key atrule" style="color:#00a4db">variables</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">:</span><span class="token front-matter-block front-matter yaml language-yaml"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block front-matter yaml language-yaml">  </span><span class="token front-matter-block front-matter yaml language-yaml key atrule" style="color:#00a4db">&quot;spec&quot;</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">:</span><span class="token front-matter-block front-matter yaml language-yaml"> /any/ </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">{</span><span class="token front-matter-block front-matter yaml language-yaml"> thread(&quot;.devin/shell/fetch</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">-</span><span class="token front-matter-block front-matter yaml language-yaml">teamai</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">-</span><span class="token front-matter-block front-matter yaml language-yaml">spec.sh&quot;) </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">|</span><span class="token front-matter-block front-matter yaml language-yaml"> jsonpath(&quot;$.</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">[</span><span class="token front-matter-block front-matter yaml language-yaml number" style="color:#36acaa">1</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">]</span><span class="token front-matter-block front-matter yaml language-yaml">.content&quot;) </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">}</span><span class="token front-matter-block front-matter yaml language-yaml"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block front-matter yaml language-yaml"></span><span class="token front-matter-block front-matter yaml language-yaml key atrule" style="color:#00a4db">onStreamingEnd</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">:</span><span class="token front-matter-block front-matter yaml language-yaml"> </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">{</span><span class="token front-matter-block front-matter yaml language-yaml"> parseCode </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">|</span><span class="token front-matter-block front-matter yaml language-yaml"> saveFile </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">|</span><span class="token front-matter-block front-matter yaml language-yaml"> openFile </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">}</span><span class="token front-matter-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block"></span><span class="token front-matter-block punctuation" style="color:#393A34">---</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">请根据用户的输入和规范，生成相应的 Proto 文件。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">规范如下：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$spec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">用户的需求是：$selection</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>只需这一段 YAML，AutoDev 就能生成一个理解团队协议规范的智能体：</p>
<ul>
<li>自动调用 <code>fetch-teamai-spec.s</code> 脚本获取需求规范</li>
<li>注入上下文信息并结合用户选中需求</li>
<li>自动生成符合要求的 <code>.proto</code> 文件并打开编辑</li>
</ul>
<p>这种原子化能力封装 + 跨工具联动方式，大大拓展了 agent 的实用边界。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-示例配置二编排的数据库设计智能体">✅ 示例配置二：编排的数据库设计智能体<a href="#-示例配置二编排的数据库设计智能体" class="hash-link" aria-label="✅ 示例配置二：编排的数据库设计智能体的直接链接" title="✅ 示例配置二：编排的数据库设计智能体的直接链接">​</a></h3>
<div class="language-devin codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-devin codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token front-matter-block punctuation" style="color:#393A34">---</span><span class="token front-matter-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block"></span><span class="token front-matter-block front-matter yaml language-yaml key atrule" style="color:#00a4db">name</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">:</span><span class="token front-matter-block front-matter yaml language-yaml"> </span><span class="token front-matter-block front-matter yaml language-yaml string" style="color:#e3116c">&quot;设计数据库&quot;</span><span class="token front-matter-block front-matter yaml language-yaml"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block front-matter yaml language-yaml"></span><span class="token front-matter-block front-matter yaml language-yaml key atrule" style="color:#00a4db">variables</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">:</span><span class="token front-matter-block front-matter yaml language-yaml"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block front-matter yaml language-yaml">  </span><span class="token front-matter-block front-matter yaml language-yaml key atrule" style="color:#00a4db">&quot;story&quot;</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">:</span><span class="token front-matter-block front-matter yaml language-yaml"> /any/ </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">{</span><span class="token front-matter-block front-matter yaml language-yaml"> thread(&quot;.devin/shell/github</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">-</span><span class="token front-matter-block front-matter yaml language-yaml">issue.curl.sh&quot;) </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">|</span><span class="token front-matter-block front-matter yaml language-yaml"> jsonpath(&quot;$.body&quot;) </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">}</span><span class="token front-matter-block front-matter yaml language-yaml"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block front-matter yaml language-yaml"></span><span class="token front-matter-block front-matter yaml language-yaml key atrule" style="color:#00a4db">afterStreaming</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">:</span><span class="token front-matter-block front-matter yaml language-yaml"> </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">{</span><span class="token front-matter-block front-matter yaml language-yaml"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block front-matter yaml language-yaml">  case condition </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">{</span><span class="token front-matter-block front-matter yaml language-yaml"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block front-matter yaml language-yaml">    default </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">{</span><span class="token front-matter-block front-matter yaml language-yaml"> execute(&quot;gen</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">-</span><span class="token front-matter-block front-matter yaml language-yaml">sql.devin&quot;</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">,</span><span class="token front-matter-block front-matter yaml language-yaml"> $story</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">,</span><span class="token front-matter-block front-matter yaml language-yaml"> $output) </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">}</span><span class="token front-matter-block front-matter yaml language-yaml"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block front-matter yaml language-yaml">  </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">}</span><span class="token front-matter-block front-matter yaml language-yaml"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block front-matter yaml language-yaml"></span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">}</span><span class="token front-matter-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block"></span><span class="token front-matter-block punctuation" style="color:#393A34">---</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">你是一位专业的数据库管理员。根据用户的需求，你应该在列表中为用户选择最佳的表。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">— 用户使用数据库：$databaseInfo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token list punctuation" style="color:#393A34">-</span><span class="token plain"> 用户表：$tables</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">例如：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token list punctuation" style="color:#393A34">-</span><span class="token plain"> 问题（要求）：按用户类型计算平均行程长度。用户表：trips, users, Subscriber_type *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token list punctuation" style="color:#393A34">-</span><span class="token plain"> 你应该回答：[trips, Subscriber_type]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token hr punctuation" style="color:#393A34">----</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">以下是用户需求：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$story</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">请为用户选择最佳的表，只需以列表形式返回表名，无需解释。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>只需这一段配置，AutoDev 会自动生成：</p>
<ul>
<li>一个能够理解数据库结构并执行 SQL 生成的智能体</li>
<li>完全根据用户输入的数据库表和需求动态生成查询</li>
<li>将查询结果传入到下一个智能体（<code>gen-sql.devin</code>）进行处理</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-示例配置三在聊天中生成代码">✅ 示例配置三：在聊天中生成代码<a href="#-示例配置三在聊天中生成代码" class="hash-link" aria-label="✅ 示例配置三：在聊天中生成代码的直接链接" title="✅ 示例配置三：在聊天中生成代码的直接链接">​</a></h3>
<p>只需要在配置中添加 <code>agentic</code> 为 <code>true</code> 的值，并将 <code>$selection</code> 改为 <code>$input</code> 变量，AutoDev 就会自动将用户的输入传递给智能体：</p>
<div class="language-devin codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-devin codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token front-matter-block punctuation" style="color:#393A34">---</span><span class="token front-matter-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block"></span><span class="token front-matter-block front-matter yaml language-yaml key atrule" style="color:#00a4db">name</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">:</span><span class="token front-matter-block front-matter yaml language-yaml"> </span><span class="token front-matter-block front-matter yaml language-yaml string" style="color:#e3116c">&quot;Design Profobuf IDL&quot;</span><span class="token front-matter-block front-matter yaml language-yaml"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block front-matter yaml language-yaml"></span><span class="token front-matter-block front-matter yaml language-yaml key atrule" style="color:#00a4db">actionLocation</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">:</span><span class="token front-matter-block front-matter yaml language-yaml"> ContextMenu</span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block front-matter yaml language-yaml"></span><span class="token front-matter-block front-matter yaml language-yaml key atrule" style="color:#00a4db">variables</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">:</span><span class="token front-matter-block front-matter yaml language-yaml"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block front-matter yaml language-yaml">  </span><span class="token front-matter-block front-matter yaml language-yaml key atrule" style="color:#00a4db">&quot;spec&quot;</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">:</span><span class="token front-matter-block front-matter yaml language-yaml"> /any/ </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">{</span><span class="token front-matter-block front-matter yaml language-yaml"> thread(&quot;.devin/shell/fetch</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">-</span><span class="token front-matter-block front-matter yaml language-yaml">teamai</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">-</span><span class="token front-matter-block front-matter yaml language-yaml">spec.sh&quot;) </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">|</span><span class="token front-matter-block front-matter yaml language-yaml"> jsonpath(&quot;$.</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">[</span><span class="token front-matter-block front-matter yaml language-yaml number" style="color:#36acaa">1</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">]</span><span class="token front-matter-block front-matter yaml language-yaml">.content&quot;) </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">}</span><span class="token front-matter-block front-matter yaml language-yaml"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block front-matter yaml language-yaml"></span><span class="token front-matter-block front-matter yaml language-yaml key atrule" style="color:#00a4db">onStreamingEnd</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">:</span><span class="token front-matter-block front-matter yaml language-yaml"> </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">{</span><span class="token front-matter-block front-matter yaml language-yaml"> parseCode </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">|</span><span class="token front-matter-block front-matter yaml language-yaml"> saveFile </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">|</span><span class="token front-matter-block front-matter yaml language-yaml"> openFile </span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">}</span><span class="token front-matter-block front-matter yaml language-yaml"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block front-matter yaml language-yaml"></span><span class="token front-matter-block front-matter yaml language-yaml key atrule" style="color:#00a4db">agentic</span><span class="token front-matter-block front-matter yaml language-yaml punctuation" style="color:#393A34">:</span><span class="token front-matter-block front-matter yaml language-yaml"> </span><span class="token front-matter-block front-matter yaml language-yaml boolean important" style="color:#36acaa">true</span><span class="token front-matter-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token front-matter-block"></span><span class="token front-matter-block punctuation" style="color:#393A34">---</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">请根据用户的输入和规范，生成相应的 Proto 文件。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">规范如下：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$spec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">用户的需求是：$input</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="总结智能体的未来是开发者驱动的自由工坊">总结：智能体的未来，是“开发者驱动”的自由工坊<a href="#总结智能体的未来是开发者驱动的自由工坊" class="hash-link" aria-label="总结：智能体的未来，是“开发者驱动”的自由工坊的直接链接" title="总结：智能体的未来，是“开发者驱动”的自由工坊的直接链接">​</a></h2>
<p>AutoDev 本地智能体系统给开发者带来了真正的控制权。</p>
<ul>
<li>你定义行为，而不是接受行为</li>
<li>你组合模块，而不是等待功能更新</li>
<li>你掌控模型，而不是被平台绑定</li>
</ul>
<p>每个开发者都应该拥有属于自己的 AI 编程助手，而不是为一个 “通用 Copilot” 妥协。</p>
<p>这，就是 AutoDev 想做的事。</p>
<p>📌 项目地址： <a href="https://github.com/unit-mesh/autodev" target="_blank" rel="noopener noreferrer">https://github.com/unit-mesh/autodev</a>
📚 文档 &amp; 快速上手： <a href="https://ide.unitmesh.cc/docs" target="_blank" rel="noopener noreferrer">https://ide.unitmesh.cc/docs</a></p></div><footer class="row docusaurus-mt-lg"></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/2025/03/26/autodev-2-0">AutoDev 2.0 正式发布！智能体 x 开源生态 = 无限可能</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2025-03-26T00:00:00.000Z">2025年3月26日</time> · <!-- -->阅读需 8 分钟</div></header><div class="markdown"><p>PS：在我们等待了几个月之后，国内终于有模型（DS V3-0324）能支持 AutoDev 的能力，也因此是时候发布 AutoDev 2.0 了！</p>
<p>2023 年 4 月，我们开始了 AutoDev 的第一个功能：AutoCRUD，经过两年的快速迭代，我们干掉了这个功能。因为新的 AutoDev 2.0 来了，智能体
驱动的 AI 编程改变了我们过去的架构。在 AutoDev 2.0 中，你可以：</p>
<ul>
<li>编码智能体 Sketch 进行自动化编程</li>
<li>自动化编程的规划器 AutoDev Planner</li>
<li>系统迁移 Bridge 辅助旧系统重构</li>
<li>观察者 Observer，动态观察 IDE 中的代码变化</li>
<li>模型协议 MCP 接入工具生态</li>
<li>在不同场景使用多种开源模型（编程、推理、Apply、补全等）</li>
<li>……</li>
</ul>
<p>更棒的是 AutoDev 2.0 是开源的，你可以自由使用、修改、分享，让我们一起来探索这个无限可能的世界！与此同时，我们是最好的
JetBrains IDE 平台上的第二代 AI 编程工具，你可以尽情利用 JetBrains 的插件生态，让 AutoDev 2.0 更加强大！</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="编码智能体-sketch">编码智能体 Sketch<a href="#编码智能体-sketch" class="hash-link" aria-label="编码智能体 Sketch的直接链接" title="编码智能体 Sketch的直接链接">​</a></h2>
<p>我们开发 AutoDev 2.0 的动机来源于：DeepSeek V3 模型的推出。我们在 Shire 智能体语言上构建了 Sketch View，并率先将其应用到多文件编程支持。
随后，我们将其应用到 AutoDev 2.0 中，通过丰富的 IDEA 插件生态，来构建更好的 IDE 编程体验。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="交互式决策视图sketch-view">交互式决策视图：Sketch View<a href="#交互式决策视图sketch-view" class="hash-link" aria-label="交互式决策视图：Sketch View的直接链接" title="交互式决策视图：Sketch View的直接链接">​</a></h3>
<p>Sketch View 提供了是一种新的交互式视图，它可以帮助你更好地理解架构、进行决策。Sketch View 的特点有：</p>
<ul>
<li><strong>交互式设计</strong>。多种化的 Patch/Diff 处理， 并针对生成代码进行 Lint 检查等</li>
<li><strong>开发者体验</strong>。前端应用在启动 dev 服务时， 自动打开 WebView 查看编译正确</li>
<li><strong>质量与安全</strong>。生成依赖文件时，可提供依赖的安全检查</li>
</ul>
<p>并且，你还可以用它来查看代码的结构，以及更好地编写代码。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="隔离环境的工具调用devins">隔离环境的工具调用：DevIns<a href="#隔离环境的工具调用devins" class="hash-link" aria-label="隔离环境的工具调用：DevIns的直接链接" title="隔离环境的工具调用：DevIns的直接链接">​</a></h3>
<p>我们在 AutoDev 1.0 中设计了 DevIns DSL 来构建隔离环境的指令抽象，基于 DevIns 指令，AutoDev 可以：</p>
<ul>
<li><strong>安全操作</strong>。对指令进行更安全的检查，诸如 Shell、SQL，而不是依赖于 LLM 的不靠谱分析。</li>
<li><strong>模型无关</strong>。即可以在不同的模型上使用 CoT 来进行工具调用，而不依赖于 function tool。</li>
<li><strong>关键上下文</strong>。即基于 IDE 的 PSI 接口丰富了语法分析计算与架构视图，提供系统的关键上下文。</li>
</ul>
<p>同时，DevIns 能和 MCP 生态非常好的结合在一起，以便于更好地调用工具。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="可见的任务规划autodev-planner">可见的任务规划：AutoDev Planner<a href="#可见的任务规划autodev-planner" class="hash-link" aria-label="可见的任务规划：AutoDev Planner的直接链接" title="可见的任务规划：AutoDev Planner的直接链接">​</a></h2>
<p>Planner 是 Sketch 的核心功能，它提供了一种新的任务规划体验。你可以通过 AutoDev Planner 来：</p>
<ul>
<li><strong>可见的任务规划</strong>。通过 Pin 及 Planner ToolWindow 的可以看到当前的任务进度</li>
<li><strong>动态的任务规划</strong>。AI 会根据上下文动态调整任务规划（取决于模型，有时候并不会实时更新）</li>
<li><strong>手动执行未完成的任务</strong>。用户可以手动执行未完成的任务，以便更好地调整任务规划</li>
</ul>
<p>结合诸如于 DeepSeek R1 这一类推理模型，AutoDev Planner 可以更好地规划任务，以适应用户需求。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="被动式错误观测observer">被动式错误观测：Observer<a href="#被动式错误观测observer" class="hash-link" aria-label="被动式错误观测：Observer的直接链接" title="被动式错误观测：Observer的直接链接">​</a></h2>
<p>Observer 是在 Sketch 中新增的一个功能，它可以帮助你更好地观察代码的变化。Observer 可以观察：</p>
<ul>
<li>测试失败。当测试失败时，Observer 可以自动带上上下文（相关代码）发给模型</li>
<li>构建失败。当构建失败时，诸如 Gradle、Maven 的构建日志会被自动发送给模型</li>
<li>添加依赖失败。当添加依赖失败时，Observer 会自动将问题反馈给模型</li>
<li>……</li>
</ul>
<p>通过被动式的错误观测，AutoDev 可以更好地理解代码的变化，以提升开发效率。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="旧系统改造智能体autodev-bridge试验性">旧系统改造智能体：AutoDev Bridge（试验性）<a href="#旧系统改造智能体autodev-bridge试验性" class="hash-link" aria-label="旧系统改造智能体：AutoDev Bridge（试验性）的直接链接" title="旧系统改造智能体：AutoDev Bridge（试验性）的直接链接">​</a></h2>
<p>Bridge 是我们针对遗留系统迁移的一个新功能，它主要包括：</p>
<ul>
<li>迁移路径。基于&quot;探索-感知-响应&quot;框架，通过大型语言模型智能生成系统迁移路径</li>
<li>架构视图。利用 AI 进行工具调用对现有系统进行深度扫描，生成符合C4模型标准的架构蓝图</li>
<li>业务逻辑分析。结合抽象语法树(AST)解析和运行时调用链追踪技术，实现业务逻辑的精准还原</li>
<li>执行迁移。生成包括单元测试、集成测试和端到端测试在内的多层次验证方案，确保迁移后系统功能完整性</li>
</ul>
<p>作为一个试验性功能，AutoDev Bridge 并没有完全成熟，但是我们相信它会在未来的迁移中发挥重要作用。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="devops-生态集成双向-mcp">DevOps 生态集成：双向 MCP<a href="#devops-生态集成双向-mcp" class="hash-link" aria-label="DevOps 生态集成：双向 MCP的直接链接" title="DevOps 生态集成：双向 MCP的直接链接">​</a></h2>
<p>MCP（模型上下文协议）是一个非常好的开放协议，它可以帮助 AI 智能体更好地理解上下文。在 AutoDev 2.0 中，我们将 MCP 与 JetBrains
插件生态
进行了双向集成，以便于更好地调用工具。</p>
<ul>
<li>MCP 即工具。通过 DevIns 指令对 MCP 进行封装，来调用第三方工具</li>
<li>AutoDev 即服务。将 AutoDev 作为一个 MCP 服务，可以被任何 Agent Tool 调用</li>
</ul>
<p>如此一来，将 AutoDev 与整个工具生态进行了无缝集成，丰富系统的上下文能力，降低幻觉的产生。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="其它">其它<a href="#其它" class="hash-link" aria-label="其它的直接链接" title="其它的直接链接">​</a></h2>
<p>我们重新写了 UI 配图页面，详细参考新文档进行配置：<a href="https://ide.unitmesh.cc/quick-start" target="_blank" rel="noopener noreferrer">https://ide.unitmesh.cc/quick-start</a></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="autodev-1x-功能">AutoDev 1.x 功能<a href="#autodev-1x-功能" class="hash-link" aria-label="AutoDev 1.x 功能的直接链接" title="AutoDev 1.x 功能的直接链接">​</a></h3>
<p>AutoDev 1.x 的功能依然保留，删除了一些用得比较少的功能，如 AutoCRUD。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="工具问题依旧效率真能提升吗">工具问题依旧，效率真能提升吗？<a href="#工具问题依旧效率真能提升吗" class="hash-link" aria-label="工具问题依旧，效率真能提升吗？的直接链接" title="工具问题依旧，效率真能提升吗？的直接链接">​</a></h3>
<p>哪怕效率提升再多，效能提升依然有限。你们在写代码上的时间到底有多少？？？？？？？？？？？？</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="安装-autodev-20">安装 AutoDev 2.0<a href="#安装-autodev-20" class="hash-link" aria-label="安装 AutoDev 2.0的直接链接" title="安装 AutoDev 2.0的直接链接">​</a></h3>
<p>你可以通过 GitHub 来下载最新版本的 AutoDev 插件：<a href="https://github.com/unit-mesh/auto-dev" target="_blank" rel="noopener noreferrer">https://github.com/unit-mesh/auto-dev</a> 。</p>
<p>也可以 <code>Settings</code> → <code>Plugins</code> → <code>Marketplace</code> → <code>Manage Plugin Repositories</code> → <code>Add</code>，添加
<a href="https://plugin.unitmesh.cc/updatePlugins.xml" target="_blank" rel="noopener noreferrer">https://plugin.unitmesh.cc/updatePlugins.xml</a> 然后搜索 <code>AutoDev</code> 进行安装。</p>
<p>我们还在努力重新上架到 JetBrains 插件市场，但是你还可以通过下载源码来手动安装。</p></div><footer class="row docusaurus-mt-lg"></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/2025/03/18/autodev-planner">AutoDev Planner</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2025-03-18T00:00:00.000Z">2025年3月18日</time> · <!-- -->阅读需 8 分钟</div></header><div class="markdown"><p>最近，我们在 AutoDev 上构建了新的功能：AutoDev Planner，它是一个基于 DeepSeek R1 推理模型构建的编码任务规划功能。当然了，除了 DeepSeek
R1 之外，你也可以使用其它模型。</p>
<p>在 AutoDev Planner 中，AI 将会根据你的输入和收集的上下文，生成一个用于后续编码的任务计划。随后，这个编码计划可以用其它指令遵循更好的模型，比如
DeepSeek V3，来生成代码、编辑代码等。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="引子-1ai-编码任务的进度显性化">引子 1：AI 编码任务的进度显性化<a href="#引子-1ai-编码任务的进度显性化" class="hash-link" aria-label="引子 1：AI 编码任务的进度显性化的直接链接" title="引子 1：AI 编码任务的进度显性化的直接链接">​</a></h2>
<p>在进行 AI 编码 Agent 的设计时，一个非常有意思的点是，用户对于编码任务的感知是怎样的，即用户应该能显性看到进度，还是隐性感知进度。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="copilot-workspace早期的-ai-显性任务">Copilot Workspace：早期的 AI 显性任务<a href="#copilot-workspace早期的-ai-显性任务" class="hash-link" aria-label="Copilot Workspace：早期的 AI 显性任务的直接链接" title="Copilot Workspace：早期的 AI 显性任务的直接链接">​</a></h3>
<p>去年，我尝试使用 GitHub Copilot Workspace 来帮助我进行前端的开发工作。我尝试了几十个小的需求点，哪怕只是简单的 i18n 翻译，它的表现并没有
我想象中的那么好，大抵是受限于 GPT 4 的能力限制。而 Copilot Workspace 的思路确实非常不错：</p>
<ul>
<li>Brainstorm。对用户的 Task 进行头脑风暴（Brainstorm）</li>
<li>Task。将 Task 转换为一个可编辑的 Plan</li>
<li>Execute。执行 Plan，生成代码 Pull Request</li>
<li>PR。将变更以 Pull Request 的形式提交</li>
</ul>
<p>你可以显性看到 AI 思考、编辑、执行的过程，当然它没有动态的去调整他的计划，而是一次性生成（基于 2024 年的认知）。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="cursorai-隐性任务下的自动化重试">Cursor：AI 隐性任务下的自动化重试<a href="#cursorai-隐性任务下的自动化重试" class="hash-link" aria-label="Cursor：AI 隐性任务下的自动化重试的直接链接" title="Cursor：AI 隐性任务下的自动化重试的直接链接">​</a></h3>
<p>回到，最近一年多特别火热的 AI 编码工具 Cursor，它构建了非常好的 AI Editor 体验，用户抛出一个问题。它会：</p>
<ul>
<li>自动收集 IDE 中的上下文</li>
<li>对代码进行编辑</li>
<li>在代码出现 Lint 问题时，自动修复；在代码出现错误时，自动重试</li>
<li>……</li>
</ul>
<p>你可以通过文字大概理解 AI 到底干了点什么，但是很快大量地重试，让你感知不到过程的存在。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="jetbrains-junie动态的-ai-任务规划">JetBrains Junie：动态的 AI 任务规划<a href="#jetbrains-junie动态的-ai-任务规划" class="hash-link" aria-label="JetBrains Junie：动态的 AI 任务规划的直接链接" title="JetBrains Junie：动态的 AI 任务规划的直接链接">​</a></h3>
<p>JetBrains Junie 算是最新 AI 编码工具，它构建了一个动态的 AI 任务规划体验。用户抛出一个问题。它会：</p>
<ul>
<li>结合分析问题，理解用户意图，生成一个任务计划</li>
<li>按步骤执行每个任务，并根据需求再获取上下文</li>
<li>在任务执行过程中，动态调整计划，以适应用户需求</li>
</ul>
<p>在过程中，你可以看到它的计划在不断调整和迭代，直到最终完成用户的 issue 或者不能完成。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="引子-2推理模型规划任务的想象空间">引子 2：推理模型规划任务的想象空间<a href="#引子-2推理模型规划任务的想象空间" class="hash-link" aria-label="引子 2：推理模型规划任务的想象空间的直接链接" title="引子 2：推理模型规划任务的想象空间的直接链接">​</a></h2>
<p>众所周知，2024 年底的推理模型或者说“可深度思考模型”，带来了更多的想象空间与可能性。我们在 AutoDev Sketch（类 Cursor Composer 自动编码 Agent）
中做了一系列的实验， 发现与其它的国内模型相比，DeepSeek R1 在相同上下文的情况下，比普通模型更容易生成更好的工具调用（ 基于DevIns 指令）。
与 DeepSeek V3 相比，DeepSeek R1 调用了更多的工具。</p>
<p>理想情况下，我们应该用 R1 进行首轮工具对话和第二轮的任务规划，但是 R1 的速度确实太慢了，从时间上来算相当于多调用了一轮 API。但是，依旧可以
看到 R1 的优势，相信大家也有相似的感受和体验。</p>
<p>当然我们没有做大规模的实验，毕竟构建非常好的测试数据集是特别花费时间的。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="autodev-planneragent-编程的任务规划">AutoDev Planner：Agent 编程的任务规划<a href="#autodev-planneragent-编程的任务规划" class="hash-link" aria-label="AutoDev Planner：Agent 编程的任务规划的直接链接" title="AutoDev Planner：Agent 编程的任务规划的直接链接">​</a></h2>
<p>基于上述的思考，我们构建了新的拟人功能：AutoDev Planner 以强化 Sketch 的任务规划能力。AutoDev Planner 的核心功能是：</p>
<ul>
<li>可见的任务规划。通过 Pin 及 Planner ToolWindow 的可以看到当前的任务进度</li>
<li>动态的任务规划。AI 会根据上下文动态调整任务规划（取决于模型，有时候并不会实时更新）</li>
<li>手动执行未完成的任务。用户可以手动执行未完成的任务，以便更好地调整任务规划</li>
<li>规划 Review。用户可以手动调用模型来 Review 任务规划（为什么不是自动的，因为 token 对普通用户来说是非常昂贵的）</li>
</ul>
<p>总体思路还是非常简单的，就只是调用模型生成计划，然后展示这个交互。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="关键点-1基于推理模型的任务规划">关键点 1：基于推理模型的任务规划<a href="#关键点-1基于推理模型的任务规划" class="hash-link" aria-label="关键点 1：基于推理模型的任务规划的直接链接" title="关键点 1：基于推理模型的任务规划的直接链接">​</a></h3>
<p>由于推理模型与普通的模型在理解 prompt 和遵循指令的能力是有差异的，我们原先用于 V3 的 prompt 并不适用于 R1。因此，我们需要重新设计 prompt
以适应 R1 的能力。</p>
<p>简单来说，就是当完成了初步的上下文收集之后， 而且用户配置了推理模型之后，我们会调用 R1 来生成一个任务计划。这个任务计划会包含：任务、步骤及
其相关的进度情况，随后我们会将这个计划展示给用户。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="关键点-2任务规划的可交互性">关键点 2：任务规划的可交互性<a href="#关键点-2任务规划的可交互性" class="hash-link" aria-label="关键点 2：任务规划的可交互性的直接链接" title="关键点 2：任务规划的可交互性的直接链接">​</a></h3>
<p>与其它的 AI 编码工具不同，我们认为任务规划是一个非常重要的交互，因此我们提供了一些交互功能：</p>
<ul>
<li>任务的状态显示：<!-- -->
<ul>
<li>完成的任务将会被标记为完成</li>
<li>未完成的任务可以手动执行</li>
</ul>
</li>
<li>Pin。用户可以将任务 Pin 到 IDE 的某个位置，以便更好地关注</li>
<li>文件交互。考虑到模型的能力，当文件出现在任务中，可以点击文件名打开文件</li>
<li>编辑。当用户觉得任务规划不合适时，可以暂停并及时调整任务。</li>
<li>review。用户可以手动调用模型来 Review 任务规划</li>
</ul>
<p>通过可视化任务来构建更好的 AI 编码体验，这是 AutoDev Planner 的初衷。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a href="#总结" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h2>
<p>AutoDev Planner 是一个基于推理模型的任务规划功能，它可以帮助用户更好地理解 AI 编码任务的进度，以及更好地调整任务规划。当然，它还有很多不足之处，
欢迎在 GitHub 上提出 issue 和 PR。</p>
<p>欢迎下载最新版本体验：<a href="https://github.com/unit-mesh/auto-dev/releases" target="_blank" rel="noopener noreferrer">https://github.com/unit-mesh/auto-dev/releases</a></p></div><footer class="row docusaurus-mt-lg"></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/2025/03/12/autodev-mcp">AutoDev MCP</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2025-03-12T00:00:00.000Z">2025年3月12日</time> · <!-- -->阅读需 7 分钟</div></header><div class="markdown"><p>在 Agentic Coding 这一话题下，工具使用（Tool Use/Function calling）是一个非常有意思的话题。完成一个软件开发任务，需要使用到大量的工具，
除去在 IDE 及其插件生态本身提供的功能外，还会使用到大量的外部工具，如 Git、Docker、Kubernetes、Jenkins 等等。如何让 AI
知道更多工具的存在以及如何使用这些工具，是一个非常有意思的话题。</p>
<p>所以，我花了一天的时间在 AutoDev 中实现了相关的功能，即 AutoDev 作为一个 MCP 服务，可以被任何 Agent Tool 调用；AutoDev 作为一个
MCP 客户端，可以调用任何 MCP 服务。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="引子-1从渐进性-ai-agent-方案到-autodev-即-mcp-服务">引子 1：从渐进性 AI Agent 方案，到 AutoDev 即 MCP 服务<a href="#引子-1从渐进性-ai-agent-方案到-autodev-即-mcp-服务" class="hash-link" aria-label="引子 1：从渐进性 AI Agent 方案，到 AutoDev 即 MCP 服务的直接链接" title="引子 1：从渐进性 AI Agent 方案，到 AutoDev 即 MCP 服务的直接链接">​</a></h2>
<p>在更庞大的 AI Agent 话题之下，比如自动化的 Computer Use 场景下，IDE 也只是一个可调用的 Agent 工具。从当前的 AI Agent
进度来看，现在的 Agent Tool 使用是一种渐进式的 AI Agent 方案 —— 毕竟写过 E2E 测试的同学都知道：操作 UI 的效率是非常之低的；以至于我们在编写
AutoDev 时，并没有写多少 UI 自动化测试。</p>
<p>我们现在考虑的 AI Coding 是以 IDE 为中心的，但是还存在一个场景是以 Agent Tool 为中心的。即：</p>
<ul>
<li>Agent 通过操纵 Browser 去获取需求信息；</li>
<li>Agent 打开 IDE 去编写代码；</li>
<li>Agent 打开 DevOps 工具去发布代码；</li>
<li>……</li>
</ul>
<p>既然借助 Agent Tool 来调用工具是 2025 年的一个趋势，那么我们为什么不将 AutoDev 作为一个 MCP 服务呢？即 AutoDev 作为一个
MCP 服务，让任何 Agent Tool 都可以调用 AutoDev 的服务。哪怕是 Cursor、Cline、GitHub Copilot 等等，都可以调用 AutoDev 的服务，以获取
IDE 中的高质量上下文。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="引子-2从-mcp-即-agent-tool-生态到-mcp-服务即-autodev-指令">引子 2：从 MCP 即 Agent Tool 生态，到 MCP 服务即 AutoDev 指令<a href="#引子-2从-mcp-即-agent-tool-生态到-mcp-服务即-autodev-指令" class="hash-link" aria-label="引子 2：从 MCP 即 Agent Tool 生态，到 MCP 服务即 AutoDev 指令的直接链接" title="引子 2：从 MCP 即 Agent Tool 生态，到 MCP 服务即 AutoDev 指令的直接链接">​</a></h2>
<p>在过去，我们在 AutoDev 中优先考虑的是借助 IDE 的生态，以及自身的插件体系，以实现 AI 更好的支持端到端的开发流程。但是，随着我们在
AutoDev 集成了更丰富的插件能力之后，我们依然需要大量的 Agent Tool。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="agent-tool-决定-ai-ide-的基线能力">Agent Tool 决定 AI IDE 的基线能力<a href="#agent-tool-决定-ai-ide-的基线能力" class="hash-link" aria-label="Agent Tool 决定 AI IDE 的基线能力的直接链接" title="Agent Tool 决定 AI IDE 的基线能力的直接链接">​</a></h3>
<p>不可否认，在我们研究了大量的 AI Coding 工具之后，我们会发现，大量的 AI Editor 基于 VSCode 时在 tool 上提供的能力非常之相似，以至于我们
可以用一张图来描述它们的能力。但是，在 IDE 上的 AI Coding 插件则提供了更加丰富的能力，如 AST、Debug、FQN 查找等等。</p>
<p>典型的基于 VSCode 的 AI Coding 工具，提供了十个左右的工具，而基于 JetBrains 的 AI Coding 插件（如 AutoDev、JetBrains
Junie）则提供了 20 个左右的工具，而这些只是基础的 IDE 上的能力。</p>
<p>而随着 AI Coding 进一步向需求、部署、运维等方向发展，相关的工具生态势必会更加丰富。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="mcp-开源生态已经形成">MCP 开源生态已经形成<a href="#mcp-开源生态已经形成" class="hash-link" aria-label="MCP 开源生态已经形成的直接链接" title="MCP 开源生态已经形成的直接链接">​</a></h3>
<p>MCP（Model Context Protocol）是由 Anthropic 公司（Claude 模型） 推出的一个协议，它通过提供一种标准化的接口，LLM
应用可以访问外部信息、工具和资源。尽管我们在 AutoDev 提供了强大的自定义能力，诸如于 Custom Agent 等能力，但是：</p>
<ul>
<li>有些工具是我们无法预知的，如某些公司内部的工具；</li>
<li>MCP 等工具的生态是非常丰富的，并且正在成为一个标准。（尽管国内可能有一些不同）</li>
</ul>
<p>但是，自打 Cursor、Cline 等编程工具引入了 MCP 之后，大量的 MCP 服务已经在国外形成了一个生态，特别是已经有了非常多的开源实现。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="autodev-x-mcp双向赋能">AutoDev x MCP：双向赋能<a href="#autodev-x-mcp双向赋能" class="hash-link" aria-label="AutoDev x MCP：双向赋能的直接链接" title="AutoDev x MCP：双向赋能的直接链接">​</a></h2>
<p>基于上述的思考，我们基于 MCP 相关的插件（MCP Plugin）和生态（io.modelcontextprotocol），构建了 AutoDev x MCP 的双向赋能方案。即：</p>
<ul>
<li>AutoDev 作为一个 MCP 服务，可以被任何 Agent Tool 调用；</li>
<li>AutoDev 作为一个 MCP 客户端，可以调用任何 MCP 服务。</li>
</ul>
<p>通过这两种方式来沉淀我们在 MCP 方面的能力。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="autodev-作为-mcp-服务端">AutoDev 作为 MCP 服务端<a href="#autodev-作为-mcp-服务端" class="hash-link" aria-label="AutoDev 作为 MCP 服务端的直接链接" title="AutoDev 作为 MCP 服务端的直接链接">​</a></h3>
<p>我们基于 JetBrains 的 MCP 方案，提供构建了 AutoDev 作为一个 MCP 服务的能力（注：需要在配置中开启 MCP 能力）。你只需要通过 JSON 来配置即可
，如下是 Cline 插件中的配置示例：</p>
<div class="language-json codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-json codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token property" style="color:#36acaa">&quot;mcpServers&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;AutoDev&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;command&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;npx&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;args&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token string" style="color:#e3116c">&quot;-y&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token string" style="color:#e3116c">&quot;@jetbrains/mcp-proxy&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;disabled&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">false</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;autoApprove&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在当前的版本里，我们只基于官方提供的能力，加了一些数据库相关的能力，其它能力需要等有合适的国产 MCP 服务后再进行扩展。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="autodev-作为-mcp-客户端">AutoDev 作为 MCP 客户端<a href="#autodev-作为-mcp-客户端" class="hash-link" aria-label="AutoDev 作为 MCP 客户端的直接链接" title="AutoDev 作为 MCP 客户端的直接链接">​</a></h3>
<p>相似的，你需要在 AutoDev 的 Custom Agent 页面配置相关的 MCP 服务，如下是 MCP 官方提供的示例</p>
<div class="language-json codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-json codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token property" style="color:#36acaa">&quot;mcpServers&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;filesystem&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;command&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;npx&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;args&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token string" style="color:#e3116c">&quot;-y&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token string" style="color:#e3116c">&quot;@modelcontextprotocol/server-filesystem&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token string" style="color:#e3116c">&quot;/Volumes/source/ai/auto-dev&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>随后，这个 MCP 服务提供的工具，就可以在 AutoDev 中被调用了。如下是转换为 DevIns 后的示例：</p>
<p>/list_directory</p>
<div class="language-json codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-json codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token property" style="color:#36acaa">&quot;path&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;/Volumes/source/ai/autocrud/docs/mcp&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>现在，借助于强大的 AutoDev DevIns Command，你可以在 AutoDev 中调用任何 MCP 服务，当然 Agent 也是可以的。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="其它">其它<a href="#其它" class="hash-link" aria-label="其它的直接链接" title="其它的直接链接">​</a></h2>
<p>人生苦短，我有 AI。</p>
<ul>
<li>详细文档见：<a href="https://ide.unitmesh.cc/mcp" target="_blank" rel="noopener noreferrer">https://ide.unitmesh.cc/mcp</a></li>
<li>欢迎下载和使用最新版本 AutoDev（v2.0.0-rc.2）进行体验。下载地址：<a href="https://github.com/unit-mesh/auto-dev/releases/tag/v2.0.0-rc.2" target="_blank" rel="noopener noreferrer">https://github.com/unit-mesh/auto-dev/releases/tag/v2.0.0-rc.2</a></li>
</ul></div><footer class="row docusaurus-mt-lg"></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/2025/03/06/autodev-bridge">AutoDev Bridge</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2025-03-06T00:00:00.000Z">2025年3月6日</time> · <!-- -->阅读需 7 分钟</div></header><div class="markdown"><p>在 2023 年，基于当时的模型能力有限，我们在 AutoDev 设计了一系列的遗留系统功能的特性。而在 2025 年，经过自动编程智能体
AutoDev Sketch 的一系列
迭代，我们开始思考如何将 AI 智能体应用到遗留系统中，便产生了 AutoDev Bridge 这个想法。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="为什么大模型能做得更好">为什么大模型能做得更好？<a href="#为什么大模型能做得更好" class="hash-link" aria-label="为什么大模型能做得更好？的直接链接" title="为什么大模型能做得更好？的直接链接">​</a></h2>
<p>过去，我们公司 Thoughtworks 在这方面有非常多的积累，包括从迁移策略的设计、安全防护网的搭建等等，但是不论哪种迁移模型（绞杀者、修缮者等）最后
都是需要人工介入的。而在 2025 年，已经有越来越多的 AI 智能体能够做到自动化迁移，因此我们进一步完善了我们的开源方案。</p>
<p>在遗留系统迁移上，为什么大模型能做得更好呢？</p>
<ul>
<li>设计合理的路径规划。通常来说，优先基于成本考虑，而大模型作为一个知识库，能非常好的给你成本评估。</li>
<li>生成架构蓝图。结合目录结构、依赖信息、API，AI 能针对于当前系统描绘出初步的架构蓝图。</li>
<li>提炼代码中的业务知识。结合 AST 等，分析现有代码的业务逻辑，再基于其重写。</li>
<li>跨语言翻译。与生成代码不同的是，LLM 能非常好的将其翻译成目标语言，只需要几十秒到几分钟的时间。</li>
<li>迁移防护网的增强。即生成自动化测试来验证迁移的正确性，实现实现精准回归测试。（注：在前端依然有所不足）</li>
<li>……</li>
</ul>
<p>所以，我们只需要思考两件事：</p>
<ul>
<li>如何让 AI 能借助工具更好地理解遗留系统？</li>
<li>如何借助降低迁移的风险？</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="autodev-bridge-如何加速老旧系统迁移">AutoDev Bridge 如何加速老旧系统迁移？<a href="#autodev-bridge-如何加速老旧系统迁移" class="hash-link" aria-label="AutoDev Bridge 如何加速老旧系统迁移？的直接链接" title="AutoDev Bridge 如何加速老旧系统迁移？的直接链接">​</a></h2>
<p>基于对遗留系统迁移的理解，我们设计了 AutoDev Bridge 的初步方案。它主要包括：</p>
<ul>
<li>LLM 生成的迁移方案。（基于“探索-感知-响应”方案）</li>
<li>基于 C4 的当前架构现状分析。（基于 AI 工具调用）</li>
<li>结合 AST 与调用链的业务逻辑分析。（AI 理解代码）</li>
<li>生成迁移测试用例。</li>
<li>AI 辅助的代码翻译。</li>
<li>……</li>
</ul>
<p>借助与 IDE 的紧密集成，AutoDev Bridge 能获得非常准确的 IDE 上下文，以进一步降低 AI 幻觉的产生。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="探索-感知-响应llm-生成的迁移方案">探索-感知-响应：LLM 生成的迁移方案<a href="#探索-感知-响应llm-生成的迁移方案" class="hash-link" aria-label="探索-感知-响应：LLM 生成的迁移方案的直接链接" title="探索-感知-响应：LLM 生成的迁移方案的直接链接">​</a></h3>
<p>在过去，我们将遗留系统迁移定义为 Cynefin 中的复杂问题，即你无法预测结果，只能通过实践来发现。于是乎，我们参考了 Cynefin
的思想，设计了现有的
AutoDev Bridge 的思维框架，即你要先探索、再感知、再响应。由于，我们预期的是模型在行动前是需要有一个蓝图（C4
模型），所以我们将这个过程分为三个阶段：</p>
<ul>
<li>探索：通过初步调用工具，获取系统的基本信息，如目录结构、依赖关系等。</li>
<li>感知：基于探索的结果，生成初步的架构蓝图、迁移方案。</li>
<li>响应：进行迁移方案的验证、生成迁移测试用例、生成迁移代码。</li>
</ul>
<p>落地到国内的模型能力下，就会由由 V3 来进行探索，R1 进行方案设计，由 V3 进行响应。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="面向架构视图的工具设计">面向架构视图的工具设计<a href="#面向架构视图的工具设计" class="hash-link" aria-label="面向架构视图的工具设计的直接链接" title="面向架构视图的工具设计的直接链接">​</a></h3>
<p>为了更好让 AI 理解当前系统的架构，我们面向架构视图设计了一系列的工具。</p>
<table><thead><tr><th>工具名称 (name)</th><th>描述 (desc)</th></tr></thead><tbody><tr><td>componentView</td><td>列出当前项目的所有UI组件列表，如React、Vue组件</td></tr><tr><td>containerView</td><td>列出当前项目的所有模块</td></tr><tr><td>webApiView</td><td>列出当前项目的所有Web API</td></tr><tr><td>stylingView</td><td>列出当前项目的所有CSS、SCSS类</td></tr><tr><td>dir</td><td>获取当前层级的目录结构</td></tr><tr><td>history</td><td>获取当前文件的历史提交信息</td></tr><tr><td>knowledge</td><td>从 API 调用链进行分析，默认 depth = 2（不可修改），即 Controller 到 Repository 的调用链</td></tr></tbody></table>
<p>注：显然 DeepSeek 不能很好理解 C4 模型，还需要进一步的优化。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="业务知识提取与理解">业务知识提取与理解<a href="#业务知识提取与理解" class="hash-link" aria-label="业务知识提取与理解的直接链接" title="业务知识提取与理解的直接链接">​</a></h3>
<p>在业务逻辑分析中，我们主要是基于 API 的 AST 与调用链的业务逻辑分析。即先通过 <code>webApiView</code> 获取所有的 API，再通过
<code>knowledge</code> 获取 API 的调用链。 如：</p>
<div class="language-devin codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-devin codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/knowledge:GET#/api/blog/*</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在有了从 Controller 到 Repository 的调用链后，AI 就可以非常好地理解当前 API 的业务逻辑。</p>
<p>当然，这只是一个简单的示例，实际上，AI 还需要结合搜索等工具，进一步获得更多的上下文。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a href="#总结" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h2>
<p>随着，我们研究的进一步深入，我们会逐步完善这个方案，以实现更好的自动化迁移。</p>
<p>欢迎在 GitHub 上持续关注我们：<a href="https://github.com/unit-mesh/auto-dev" target="_blank" rel="noopener noreferrer">https://github.com/unit-mesh/auto-dev</a></p></div><footer class="row docusaurus-mt-lg"></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/2025/01/11/autodev-2-0-preview">AutoDev Composer the Intellij IDEA Cursor Alternative</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2025-01-11T00:00:00.000Z">2025年1月11日</time> · <!-- -->阅读需 4 分钟</div></header><div class="markdown"><p>A little over two weeks ago, after the release of DeepSeek V3, we introduced multi-file editing capabilities for Shire.</p>
<p>Following extensive testing, we discovered that DeepSeek V3 performs exceptionally well in programming scenarios,
especially in multi-file editing contexts.</p>
<p>This inspired us to add a new feature—<strong>AutoDev Composer</strong>—to AutoDev, which had long lacked major updates. In
developing this feature, we drew inspiration from a number of mature tools:</p>
<ul>
<li>The impressive <strong>Sketch rendering mechanism</strong> on Shire</li>
<li>Complex <strong>system prompts</strong> from tools like Cursor and WindSurf</li>
<li>The bug-ridden <strong>StreamDiff mode</strong> from Continue</li>
<li>…and more</li>
</ul>
<p>Now, there’s no need to switch to a VSCode-like IDE to craft prompts and then return to IntelliJ IDEA for debugging.
With AutoDev Composer, you can handle everything directly within IntelliJ IDEA.</p>
<p>As an amateur project, we’ve put in a lot of effort to make this happen! 😊</p>
<p>Introduction paragraph text here.</p></div><footer class="row docusaurus-mt-lg"><div class="col text--right"><a aria-label="阅读 AutoDev Composer the Intellij IDEA Cursor Alternative 的全文" href="/blog/2025/01/11/autodev-2-0-preview"><b>阅读更多</b></a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/2024/03/17/autodev-devins-language">Agent Language - DevIns</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2024-03-17T00:00:00.000Z">2024年3月17日</time> · <!-- -->阅读需 7 分钟</div></header><div class="markdown"><p>在上一个版本中，我们构建了 AutoDev 的自定义 Agent 功能，即用户可以通过自定义能力来构建自己的智能体，以实现对于软件开发任务的智能辅助。
而在这个版本中，我们开始构建一个新的 AI Agent 语言：DevIns，即 Development Instruction。即 DevIns 可以让用户更快速描述软件开发任务，
同时，还可以自动化处理来自 AI Agent 返回的内容。</p>
<p>Introduction paragraph text here.</p></div><footer class="row docusaurus-mt-lg"><div class="col text--right"><a aria-label="阅读 Agent Language - DevIns 的全文" href="/blog/2024/03/17/autodev-devins-language"><b>阅读更多</b></a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/2024/03/07/autodev-1-7-0">AutoDev 1.7.0 AutoDev AI Agent</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2024-03-07T00:00:00.000Z">2024年3月7日</time> · <!-- -->阅读需 4 分钟</div></header><div class="markdown"><p>在开源 AI IDE 插件 AutoDev 的  <a href="https://github.com/unit-mesh/auto-dev/issues/51" target="_blank" rel="noopener noreferrer">#51</a> issue 中，我们设计了 AutoDev 的 AI
Agent 能力，半年后我们终于交付了这个功能。</p>
<p>在 AutoDev 1.7.0 中，你将可以接入内部的 AI Agent，并将其无缝与现有的 AI 辅助能力结合在一起。</p>
<p>Introduction paragraph text here.</p></div><footer class="row docusaurus-mt-lg"><div class="col text--right"><a aria-label="阅读 AutoDev 1.7.0 AutoDev AI Agent 的全文" href="/blog/2024/03/07/autodev-1-7-0"><b>阅读更多</b></a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/2024/02/25/autodev-1-6-4">AutoDev 1.6.4 HarmonyOS 应用开发体验提升</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2024-02-25T00:00:00.000Z">2024年2月25日</time> · <!-- -->阅读需 9 分钟</div></header><div class="markdown"><p>生成式 AI 在软件研发和知识管理上，有着非常大的潜力，也因此这项技术被越来越多的企业所采用。而在一些新兴的技术上，诸如于鸿蒙操作系统，它带来了一些新
的理念、开发工具 DevEco Studio、新的语言 ArkTS、新的 UI 框架 ArkUI 等等。从模式上来说，它与生成式 AI 结合企业内部的基础设施过程非常相似。</p>
<p>因此，我们开始在 AutoDev 中探索如何结合这些新知识的可能性，同时降低开发人员的学习负担。</p>
<p>源码：<a href="https://github.com/unit-mesh/auto-dev" target="_blank" rel="noopener noreferrer">https://github.com/unit-mesh/auto-dev</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="鸿蒙操作系统--生成式-ai-的三个试验式功能">鸿蒙操作系统 + 生成式 AI 的三个试验式功能<a href="#鸿蒙操作系统--生成式-ai-的三个试验式功能" class="hash-link" aria-label="鸿蒙操作系统 + 生成式 AI 的三个试验式功能的直接链接" title="鸿蒙操作系统 + 生成式 AI 的三个试验式功能的直接链接">​</a></h2>
<p>在初步听鸿蒙团队介绍完 HarmonyOS 的一些自研工具之后，便有了三个在 AutoDev 试验的思路：</p>
<ul>
<li>添加 ArkTS 支持。ArkTS 是鸿蒙生态中基于 TypeScript 扩展的应用开发语言。</li>
<li>自动 ArkUI 页面生成。ArkUI 是一套构建分布式应用界面的声明式 UI 开发框架。它与我们先前引入的 AutoPage
并没有太多的区别，可以结合思维链进行代码和 UI 生成。</li>
<li>UI 布局迁移。即将其它语言、框架编写的代码，交由生成式 AI 转化成适用于鸿蒙的代码。</li>
</ul>
<p>作为阅读过 Gradle、Intellij Community、DevEcoStudio 源码，以及《前端架构：从入门到微前端》作者，我大抵算是对于 TypeScript、
ArkUI、
声明式 UI 有一定的经验，所以我自信的开始了 AutoDev 的新功能开发 —— 然后就踩了一堆坑。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-arkts-语言的-ai-支持">1. ArkTS 语言的 AI 支持<a href="#1-arkts-语言的-ai-支持" class="hash-link" aria-label="1. ArkTS 语言的 AI 支持的直接链接" title="1. ArkTS 语言的 AI 支持的直接链接">​</a></h2>
<p>在我下载安装完 DevEco Studio 之后，发现 AutoDev 居然不支持 TypeScript？？？经过我在 WebStorm 反复测试后，发现是 IDE 的关系。结合
PSIViewer 插件后，
才发现差异之后，DevEco Studio 的 JavaScript/TypeScript
语言是自己实现的，诸如于：<code>com.huawei.ace.language.psi.impl.JavaScriptIdentifierNameImpl</code>。</p>
<p>原因不外乎：</p>
<ul>
<li>Intellij 平台中的 JavaScript 插件是收费的，没有开源版本。</li>
<li>鸿蒙直接针对于 TypeScript 语法进行扩展，会比实现一个新的更简单。</li>
</ul>
<p>所以 DevEco Studio 自研了一个 JavaScript/TypeScript 模块，支持 JavaScript 语法高亮、代码提示、代码格式化等功能。与此同时，DevEco
Studio
添加了 ArkTS 语言，即 TypeScript 扩展语法。</p>
<p>这就意味着，使用 DevEco Studio + AutoDev 时，会出现三种新的文件类型：</p>
<ul>
<li>Huawei JavaScript</li>
<li>Huawei TypeScript</li>
<li>Huawei ArkTS</li>
</ul>
<p>头疼。。</p>
<p>为此，在 AutoDev 中采取的方法是，其于标准 PSI 做初步的抽象，以实现对于文档生成的支持。而如果要做好则需要：</p>
<ol>
<li>基于反射来重复利用 JavaScript PSI</li>
<li>融入 DevEco Studio 的 JavaScript 支持</li>
</ol>
<p>当然，考虑到调试上的难度，以前代码中各种现的 xxStudio 字眼（新的自研 IDE 平台？？），我暂时放弃了上述的做法：大体上鸿蒙 IDE
会有自己的 AI 能力。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-autoarkuirag-增强的-arkui-代码生成">2. AutoArkUI：RAG 增强的 ArkUI 代码生成<a href="#2-autoarkuirag-增强的-arkui-代码生成" class="hash-link" aria-label="2. AutoArkUI：RAG 增强的 ArkUI 代码生成的直接链接" title="2. AutoArkUI：RAG 增强的 ArkUI 代码生成的直接链接">​</a></h2>
<blockquote>
<p>ArkUI 是一套构建分布式应用界面的声明式 UI 开发框架。</p>
</blockquote>
<p>与 ArkTS 相比，要结合 ArkUI 显得稍微复杂一些。 所以，我在当前版本里考虑的是：结合经典 UI 的元素生成页面，即：</p>
<ul>
<li>布局。诸如于：线性布局（Row、Column）、层叠布局（Stack）、弹性布局（Flex）等。</li>
<li>组件。诸如于：按钮（Button）、单选框（Radio）、切换按钮（Toggle）等。</li>
</ul>
<p>而由于 ChatGPT 是不包含 HarmonyOS 的最新知识的，所以需要采用类似于 AutoPage 的两步生成特性。</p>
<ol>
<li>分析用户的需求，选择合适的布局与组件。</li>
<li>根据用户的需求与详细的布局、组件信息，生成对应的 ArkUI 代码。</li>
</ol>
<p>上述的两步便是 AutoDev 中 AutoArkUi 生成 UI 的特性，详细可以参考 AutoDev 的代码，以及对应的 prompt。如下是对应的步骤 1 的
prompt：</p>
<ul>
<li>User: // maybe send Android Layout code, maybe some requirements</li>
<li>Your Answer: [FlexLayout, Button, CheckBox, Checkbox, Button]</li>
</ul>
<p>考虑到编程语言 DSL（领域特定语言）极易受用户语言的影响，所以采用的是英语的方式，避免无端生成中文 DSL 。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="3-迁移-androidios小程序-应用">3. 迁移 Android/iOS/小程序 应用<a href="#3-迁移-androidios小程序-应用" class="hash-link" aria-label="3. 迁移 Android/iOS/小程序 应用的直接链接" title="3. 迁移 Android/iOS/小程序 应用的直接链接">​</a></h2>
<p>生成式 AI 具备极好的代码翻译能力。诸如于 IBM 在 Cobol 转化为 Java 上的工程化设计，以及我们在 AutoDev 中设计的遗留系统改造能力，其所针对的
都是生成 AI 在这方面的能力。</p>
<p>所以，我们也在 AutoDev 中内置了这个功能，只是当前支持的只是布局上的迁移。但是，考虑到这种生成方式依旧有一系列的问题，有待我们进一步寻找更好的方式。
类似的问题在生成 ArkUI 也是存在的。</p>
<p>相似的，这个功能目前是与 AutoArkUI 融合在一起的，理论上通过静态代码分析是最简单的，有待未来进一步完善。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="4-rag-增强的聊天上下文c-napi-等">4. RAG 增强的聊天上下文：C++ NAPI 等<a href="#4-rag-增强的聊天上下文c-napi-等" class="hash-link" aria-label="4. RAG 增强的聊天上下文：C++ NAPI 等的直接链接" title="4. RAG 增强的聊天上下文：C++ NAPI 等的直接链接">​</a></h2>
<p>在试验了多次之后，会发现对于 HarmonyOS 这种新知识，ChatGPT 是不知道的。所以，需要基于 AutoDev 的上下文接口，创建基于
HarmonyOS 的上下文。
当然的版本（1.6.4）里， 添加的是：<code>This project is a HarmonyOS project.</code> （毫无意义的废话），再结合不同语言来写一些上下文：</p>
<ul>
<li>TypeScript/JavaScript/ArkTS. Which use TypeScript (ArkTS) as the main language, and use Flutter like TypeScript UI
framework.</li>
<li>CPP/&quot;C/C++&quot;/CCE. Which use C++ as the main language, and NAPI for building native Addons.</li>
</ul>
<p>大体来说，就是告诉 AI：</p>
<ul>
<li>编写 ArkUI/前端代码的时候，考虑一下这个项目是类似于 Flutter 的声明式 UI 。</li>
<li>编写原生代码的时候，考虑一下这个项目是基于 NAPI 来构建插件的。</li>
</ul>
<p>当然了，这些是基于我的初步理解所构建的上下文，</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="未来">未来<a href="#未来" class="hash-link" aria-label="未来的直接链接" title="未来的直接链接">​</a></h2>
<p>考虑到上述的功能，就是几小时内实现的，就不要有太高的期望了。</p>
<p>当前版本依旧有诸多问题：</p>
<ul>
<li>转换 Android 布局易瞎编。除了需要知道更多的转换规则，还需要知识更多的属性，而这些部分是通过传统的代码分析工具解决的</li>
<li>组件和布局信息的 hardcode。懂的都懂</li>
<li>缺少示例代码。没有动态生成的示例代码，使得 RAG 的效果是有限的</li>
<li>诸如于 C++ 语言的支持</li>
<li>微信小程序等小程序平台的转换</li>
</ul>
<p>然而我并非 Android、小程序应用迁移到鸿蒙应用的专家，所以还是有一系列的挑战。等我心情好的时候，再考虑写一些更好玩的新特性。</p></div><footer class="row docusaurus-mt-lg"></footer></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--next" href="/blog/page/2"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">文档</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/intro">教程</a></li></ul></div><div class="col footer__col"><div class="footer__title">博客</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">博客</a></li></ul></div><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/unit-mesh/auto-dev" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Unit Mesh. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>