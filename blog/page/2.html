<!doctype html>
<html lang="zh-CN" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">Blog | AutoDev - Open Source AI Coding Wizard</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://ide.unitmesh.cc/blog/page/2"><meta data-rh="true" property="og:locale" content="zh_CN"><meta data-rh="true" property="og:locale:alternate" content="en_US"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="Blog | AutoDev - Open Source AI Coding Wizard"><meta data-rh="true" name="description" content="Blog"><meta data-rh="true" property="og:description" content="Blog"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://ide.unitmesh.cc/blog/page/2"><link data-rh="true" rel="alternate" href="https://ide.unitmesh.cc/en/blog/page/2" hreflang="en-US"><link data-rh="true" rel="alternate" href="https://ide.unitmesh.cc/blog/page/2" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="https://ide.unitmesh.cc/blog/page/2" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"Blog","@id":"https://ide.unitmesh.cc/blog/page/2","mainEntityOfPage":"https://ide.unitmesh.cc/blog/page/2","headline":"Blog","description":"Blog","blogPost":[{"@type":"BlogPosting","@id":"https://ide.unitmesh.cc/blog/autodev-coder","mainEntityOfPage":"https://ide.unitmesh.cc/blog/autodev-coder","url":"https://ide.unitmesh.cc/blog/autodev-coder","headline":"AutoDev Coder","name":"AutoDev Coder","description":"太长不读性：","datePublished":"2024-01-07T00:00:00.000Z","author":[],"keywords":[]},{"@type":"BlogPosting","@id":"https://ide.unitmesh.cc/blog/2023/10/22/autodev-1-4-0","mainEntityOfPage":"https://ide.unitmesh.cc/blog/2023/10/22/autodev-1-4-0","url":"https://ide.unitmesh.cc/blog/2023/10/22/autodev-1-4-0","headline":"AutoDev 1.4 规模化 AI 研发辅助","name":"AutoDev 1.4 规模化 AI 研发辅助","description":"在过去的两个月里，随着 Thoughtworks 内部的大规模 AI 辅助软件交付（AI4SoftwareDelivery）的展开 —— 在全球，有上千名的","datePublished":"2023-10-22T00:00:00.000Z","author":[],"keywords":[]},{"@type":"BlogPosting","@id":"https://ide.unitmesh.cc/blog/autodev-1-0-0","mainEntityOfPage":"https://ide.unitmesh.cc/blog/autodev-1-0-0","url":"https://ide.unitmesh.cc/blog/autodev-1-0-0","headline":"AutoDev 1.0 发布，全流程 AI 辅助编程","name":"AutoDev 1.0 发布，全流程 AI 辅助编程","description":"四月，在那篇《AutoDev：AI 突破研发效能，探索平台工程新机遇》，我们初步拟定了 AI 对于研发的影响。我们有了几个基本的假设：","datePublished":"2023-08-06T00:00:00.000Z","author":[],"keywords":[]},{"@type":"BlogPosting","@id":"https://ide.unitmesh.cc/blog/autodev-0-7-0","mainEntityOfPage":"https://ide.unitmesh.cc/blog/autodev-0-7-0","url":"https://ide.unitmesh.cc/blog/autodev-0-7-0","headline":"AutoDev 0.7.0 - 生成规范化代码，深入开发者日常","name":"AutoDev 0.7.0 - 生成规范化代码，深入开发者日常","description":"几个月前，我们朝着探索：如何结合 AIGC 的研发效能提升的目标？开源了 AutoDev，如 GitHub 所介绍的：","datePublished":"2023-07-23T00:00:00.000Z","author":[],"keywords":[]}]}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="AutoDev - Open Source AI Coding Wizard RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="AutoDev - Open Source AI Coding Wizard Atom Feed"><link rel="stylesheet" href="/assets/css/styles.e089f9ae.css">
<script src="/assets/js/runtime~main.0874ffc2.js" defer="defer"></script>
<script src="/assets/js/main.50bcbbd2.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/img/logo.svg"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="AutoDev 标志" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="AutoDev 标志" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">AutoDev</b></a><a class="navbar__item navbar__link" href="/intro">文档</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">博客</a><a class="navbar__item navbar__link" href="/architecture/overview">Architecture</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>简体中文</a><ul class="dropdown__menu"><li><a href="/en/blog/page/2" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en-US">English</a></li><li><a href="/blog/page/2" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="zh-CN">简体中文</a></li></ul></div><a href="https://github.com/unit-mesh/auto-dev" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><div role="group"><h3 class="yearGroupHeading_rMGB">2025</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2025/03/26/autodev-2-0">AutoDev 2.0 正式发布！智能体 x 开源生态 = 无限可能</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2025/03/18/autodev-planner">AutoDev Planner</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2025/03/12/autodev-mcp">AutoDev MCP</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2025/03/06/autodev-bridge">AutoDev Bridge</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2025/01/11/autodev-2-0-preview">AutoDev Composer the Intellij IDEA Cursor Alternative</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2024</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2024/03/17/autodev-devins-language">Agent Language - DevIns</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2024/03/07/autodev-1-7-0">AutoDev 1.7.0 AutoDev AI Agent</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2024/02/25/autodev-1-6-4">AutoDev 1.6.4 HarmonyOS 应用开发体验提升</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2024/01/26/autodev-1-6-0">AutoDev 1.6.0 精准页面生成与 SQL 生成</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2024/01/12/autodev-1-5-3">AutoDev 1.5.3 精准测试生成</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/autodev-coder">AutoDev Coder</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2023</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/10/22/autodev-1-4-0">AutoDev 1.4 规模化 AI 研发辅助</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/autodev-1-0-0">AutoDev 1.0 发布，全流程 AI 辅助编程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/autodev-0-7-0">AutoDev 0.7.0 - 生成规范化代码，深入开发者日常</a></li></ul></div></nav></aside><main class="col col--7"><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/autodev-coder">AutoDev Coder</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2024-01-07T00:00:00.000Z">2024年1月7日</time> · <!-- -->阅读需 3 分钟</div></header><div class="markdown"><p>太长不读性：</p>
<p>适用于 AutoDev 的编码大模型 AutoDev Coder 6.7B 第一个<strong>勉强可用</strong>的版本出来的。</p>
<ul>
<li>HuggingFace 首页：<a href="https://huggingface.co/unit-mesh/autodev-coder" target="_blank" rel="noopener noreferrer">https://huggingface.co/unit-mesh</a> （暂时没有资质提供直接下载，🐶🐶）。</li>
<li>数据集下载地址：<a href="https://huggingface.co/datasets/unit-mesh/autodev-datasets" target="_blank" rel="noopener noreferrer">https://huggingface.co/datasets/unit-mesh/autodev-datasets</a></li>
</ul>
<p>PS：由于 AutoDev 1.5.1 在 JetBrains 市场等待审批，而老外们正在休完假，所以模型在 1.5.1 上的体验会比 1.5.0 <strong>略微</strong>好一点。</p>
<p>除此，在有了更好的算力支持，经过更好的补全测试之后，我们也会将原来的 Inlay 补全模式加回来。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="autodev-coder-67b-v1-试验版">AutoDev Coder 6.7B v1 试验版<a href="#autodev-coder-67b-v1-试验版" class="hash-link" aria-label="AutoDev Coder 6.7B v1 试验版的直接链接" title="AutoDev Coder 6.7B v1 试验版的直接链接">​</a></h2>
<p>当前版本基于 LLaMA 架构下的 DeepSeek Coder 6.7b instruct 模型微调的。</p>
<p>注意事项：作为试验版，主要是为了磨合模型、数据工具与 IDE 插件，以达成更好的协调。因此，在生成质量还需要进一步提高。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="autodev-coder-64k-数据集">AutoDev Coder 64k 数据集<a href="#autodev-coder-64k-数据集" class="hash-link" aria-label="AutoDev Coder 64k 数据集的直接链接" title="AutoDev Coder 64k 数据集的直接链接">​</a></h2>
<p>如下是 AutoDev Coder v1 64k 的指令组成：</p>
<table><thead><tr><th>文件名</th><th>选取的指令数</th></tr></thead><tbody><tr><td>java_oss.jsonl</td><td>4000</td></tr><tr><td>python_oss.jsonl</td><td>4000</td></tr><tr><td>code_bugfix_cleaned_5K.json</td><td>4000</td></tr><tr><td>codeGPT_CN_cleaned_20K.json</td><td>15000</td></tr><tr><td>code_summarization_CN_cleaned_10K.json</td><td>8000</td></tr><tr><td>code_generation_CN_cleaned_5K.json</td><td>4000</td></tr><tr><td>summary.jsonl</td><td>25000</td></tr></tbody></table>
<p>其中的 summary.jsonl 是由我们开源的代码微调数据框架 UnitGen 生成（<a href="https://github.com/unit-mesh/unit-gen%EF%BC%89%E3%80%82" target="_blank" rel="noopener noreferrer">https://github.com/unit-mesh/unit-gen）。</a></p>
<p>我们挑选了几十个开源软件 Java 和 Kotlin 语言，根据 AutoDev 插件的指令生成，主要分为三类：</p>
<ul>
<li>补全（行内、行间、块间）</li>
<li>文档生成</li>
<li>注释生成</li>
</ul>
<p>详细说明可以见 UnitGen 项目和文档：<a href="https://github.com/unit-mesh/unit-gen%E3%80%82" target="_blank" rel="noopener noreferrer">https://github.com/unit-mesh/unit-gen。</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="faqautodev-coder-模型评估">FAQ：AutoDev Coder 模型评估<a href="#faqautodev-coder-模型评估" class="hash-link" aria-label="FAQ：AutoDev Coder 模型评估的直接链接" title="FAQ：AutoDev Coder 模型评估的直接链接">​</a></h2>
<p>暂时还在设计中。由于我们需要结合 AutoDev 指令与不同的语言如 Java、 Kotlin 、TypeScript 等语言，而非各种开源模型中喜欢用的 Python 体系，所以需要重新思考怎么设计。</p>
<p>我们前期采用 OSS Instruct 等指令集作为自然语言生成代码的补充，后来发现有一半的指令（～50，000 ）与 Python 相关，后来从中刷选出 Java 大概在 ~5，000 左右。在 AutoDev 中采用结果并不是很好。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="faqautodev-指令">FAQ：AutoDev 指令<a href="#faqautodev-指令" class="hash-link" aria-label="FAQ：AutoDev 指令的直接链接" title="FAQ：AutoDev 指令的直接链接">​</a></h2>
<p>AutoDev 采用的是相关上下文策略，所以在指令上与其它工具有所差异。详细见：<a href="https://github.com/unit-mesh/auto-dev" target="_blank" rel="noopener noreferrer">https://github.com/unit-mesh/auto-dev</a></p></div><footer class="row docusaurus-mt-lg"></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/2023/10/22/autodev-1-4-0">AutoDev 1.4 规模化 AI 研发辅助</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-22T00:00:00.000Z">2023年10月22日</time> · <!-- -->阅读需 9 分钟</div></header><div class="markdown"><p>在过去的两个月里，随着 Thoughtworks 内部的大规模 AI 辅助软件交付（AI4SoftwareDelivery）的展开 —— 在全球，有上千名的
Thoughtworker 这一个涉及不同角色、不同地区，以及几十场内部分享的活动。</p>
<p>我们也在 AutoDev 加入了更多的新特性，以持续探索如何在 IDE 里更好的协助团队进行提效。为此，作为目前国内最好的开源 AI
辅助编程工具，我们在 AutoDev 1.4.0 引入了几个比较有趣的特性，以探索规模化的 AI 研发提效。</p>
<p>AutoDev GitHub：<a href="https://github.com/unit-mesh/auto-dev" target="_blank" rel="noopener noreferrer">https://github.com/unit-mesh/auto-dev</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="团队-prompts代码化-prompt以在团队扩散">团队 Prompts：代码化 Prompt，以在团队扩散<a href="#团队-prompts代码化-prompt以在团队扩散" class="hash-link" aria-label="团队 Prompts：代码化 Prompt，以在团队扩散的直接链接" title="团队 Prompts：代码化 Prompt，以在团队扩散的直接链接">​</a></h2>
<p>为了响应我同事们对于 TDD （测试驱动开发）的热情，即 #49 issue 中对于《支持TDD开发模式，根据指定测试生成对应实现》，我们构建了
Team Prompts 的功能。现在，你可以在你的代码库里，直接编写 Prompt，AutoDev 将读取您编写的 Prompt，并成为 AI 辅助功能的一部分。</p>
<p><img decoding="async" loading="lazy" src="https://prod-files-secure.s3.us-west-2.amazonaws.com/ba3432d7-a5ac-428b-9d05-6d088dd5940a/5cecc645-e9fd-466a-8adc-2f69b15299e3/Untitled.png" alt="Untitled" class="img_ev3q"></p>
<p>这意味着：</p>
<ul>
<li>您可以在团队里，共享你的 prompt，而不再是个性化的配置。</li>
<li>您组织里的不同团队，可以在各自的团队里分享自己的 AI 经验。</li>
<li>您不再需要定制更多的 IDE 需求，只需要提供接口能力即可。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="team-prompts-示例">Team Prompts 示例<a href="#team-prompts-示例" class="hash-link" aria-label="Team Prompts 示例的直接链接" title="Team Prompts 示例的直接链接">​</a></h3>
<p>让我们来看一个简单的示例，首先你需要在你的代码库里创建（或者配置） Prompt 文件夹，然后使用编写你的一系列 Prompt，诸如于 TDD
里可以是：</p>
<ul>
<li>Tasking.vm，用于根据需求拆分出对应的测试用例。</li>
<li>TDD-Red.vm，根据生成的测试用例，编写第一个失败的测试。</li>
<li>TDD-Green.vm，根据生成的测试，编写、优化对应的实现代码。</li>
<li>TDD-Refactor.vm，重构实现的代码。</li>
</ul>
<p>在这些 prompt 文件里，只需要根据 AutoDev 的配置文件引入对应的上下文变量（参考：<a href="https://ide.unitmesh.cc/variables" target="_blank" rel="noopener noreferrer">https://ide.unitmesh.cc/variables</a> ） 即可。诸如：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">---</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">priority: 2023</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interaction: ChatPanel</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">```user```</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">你是一个资深的软件开发工程师，你擅长使用 TDD 的方式来开发软件，你需要根据新的测试用例，来改进原有的代码实现。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">原有的实现代码是：$context.underTestFileCode($methodName)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">新的测试代码是：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">${selection}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">请根据新的测试，优化 class under test 部分的代码。请返回对应的方法的代码，使用 ``` 开始你的代码块：</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Prompt 开头的部分是一个 Markdown 的 YAML FrontMatter，用于做一些简单的配置，在这里的 priority 用于配置菜单中的优先级，interaction
即是用于配置交互方式，如：</p>
<ul>
<li><code>ChatPanel</code> 用于直接输出在右侧的聊天窗口；</li>
<li><code>AppendCursorStream</code> 则是用 Stream （打字机效果）的方式在当前文档输出。</li>
</ul>
<p>Context 则是内置的一些系统函数，用于提供额外的能力支持。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="team-prompts-vs-custom-prompt">Team Prompts vs Custom Prompt<a href="#team-prompts-vs-custom-prompt" class="hash-link" aria-label="Team Prompts vs Custom Prompt的直接链接" title="Team Prompts vs Custom Prompt的直接链接">​</a></h3>
<p>在 AutoDev 1.1 中，我们提供了 Custom Prompt 的功能，它的主要意图是为个人提供一些个性化的配置，而 Team Prompts
则是针对于团队来提供团队统一的配置能力。</p>
<p>通过 Team Prompts 这样的方式，我们可以编写一系列适用于不同场景的 AI 指令，并快速分享给团队的所有人。</p>
<p>我们将持续演进 Team Prompts，以更方便地让大家使用。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="自定义活文档持续辅助遗留系统重构">自定义活文档：持续辅助遗留系统重构<a href="#自定义活文档持续辅助遗留系统重构" class="hash-link" aria-label="自定义活文档：持续辅助遗留系统重构的直接链接" title="自定义活文档：持续辅助遗留系统重构的直接链接">​</a></h2>
<p>与普通的文档生成、注释生成相对，我们觉得从底层支持对于代码的注释生成，进而辅助系统进行重构显得更有意义。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="autodev-文档生成">AutoDev 文档生成<a href="#autodev-文档生成" class="hash-link" aria-label="AutoDev 文档生成的直接链接" title="AutoDev 文档生成的直接链接">​</a></h3>
<p>在参考了 JetBrains AI Assistant 的文档生成思想之后，我们也在 AutoDev 中添加了文档生成这种聊胜于无的功能 —— 从个人角度而言，在有了
AIGC 之后，这种功能象征意义大于实际意义。直到我需要我为 Chocolate Factory 添加文档的时候，发现这个功能真好用。</p>
<p>没啥说的，选中一个类、方法、变量，右键一下，或者按一下 Alt + Enter 就可以生成了。如果原先的方法和类中已经有文档，那么将会根据现有的代码和文档重新生成（大概率，取决于
AI 的脾气了）。</p>
<p>如果您在实现的一个对外的 SDK，那么我更建议你采用我们在《*
*<a href="https://dx.phodal.com/docs/patterns/document-engineering.html" target="_blank" rel="noopener noreferrer">开发者体验：探索与重塑</a>**》中定义的《<strong>文档工程</strong>
》的方式。诸如于我们在 Chocolate Factory 中提供的，根据测试用例代码和注释来生成真正可靠的代码。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="自定义活文档生成">自定义活文档生成<a href="#自定义活文档生成" class="hash-link" aria-label="自定义活文档生成的直接链接" title="自定义活文档生成的直接链接">​</a></h3>
<p>作为曾经的遗留系统重构专家，写过几个流行的重构工具、电子书，以及我们公司同事在大型保险公司的经历来看，直接根据代码生成注解形式的文档，可以大大节省阅读大量的成本。并且在已有的代码 +
新的文档的注释基础上，我们可以更好地构建 RAG 能力，进而快速从代码中梳理出真正有用的知识。</p>
<p>为此在 AutoDev 里，只需要添加一些 examples，就可以让 LLM 来生成对应的文档。示例：</p>
<div class="language-json codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-json codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token property" style="color:#36acaa">&quot;documentations&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token property" style="color:#36acaa">&quot;title&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;Living Documentation&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token property" style="color:#36acaa">&quot;prompt&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;编写 Living Documentation。按如下的格式返回：&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token property" style="color:#36acaa">&quot;start&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token property" style="color:#36acaa">&quot;end&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token property" style="color:#36acaa">&quot;type&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;annotated&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token property" style="color:#36acaa">&quot;example&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token property" style="color:#36acaa">&quot;question&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;...&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token property" style="color:#36acaa">&quot;answer&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;...&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>再根据不同的场景，生成对应的注解格式，所以你也可以用它来生成 Swagger 注解，这样就可以直接生成 API 文档了。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="代码检视">代码检视<a href="#代码检视" class="hash-link" aria-label="代码检视的直接链接" title="代码检视的直接链接">​</a></h2>
<p>如我们在先前的文档《*
<em><a href="https://www.phodal.com/blog/llm-empowered-software-engineering-code-review/" target="_blank" rel="noopener noreferrer">AIGC 重塑软件工程 Code Review 篇</a></em>*
》所介绍，我们是通过在 AutoDev 结合 DevOps 平台来共同完成代码检视的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="ide-侧应该如何检视代码">IDE 侧应该如何检视代码<a href="#ide-侧应该如何检视代码" class="hash-link" aria-label="IDE 侧应该如何检视代码的直接链接" title="IDE 侧应该如何检视代码的直接链接">​</a></h3>
<p>在 IDE 侧，我们更推荐的方式是理解业务场景，结合部分的语法问题进行 review。其主要原则是，从我们日常的工作习惯来说，我们会选取多次提交（诸如一个需求的所有代码提交），再进行
Code Review。又或者是单个文件在历史周期上的变化，所以我们在设计上也是围绕于日常的使用习惯来配置的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="结合需求系统的-code-review">结合需求系统的 Code Review<a href="#结合需求系统的-code-review" class="hash-link" aria-label="结合需求系统的 Code Review的直接链接" title="结合需求系统的 Code Review的直接链接">​</a></h3>
<p>对于考虑 AIGC 来进行研发提效的团队而言，大部分的团队已经具备了相当 DevOps 成熟度，诸如于在提交信息里结合需求 ID
来进行提交，诸如于 <code>feat(devops): init first review command #8</code>。</p>
<p>在这种场景之下，AutoDev 会根据这里的 8 去获取对应的需求系统的信息，以此作为业务上下文，来补充我们所需要的业务上下文，进而作为
LLM 的补充信息。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a href="#总结" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h2>
<p>作为一个开源项目，我们依旧有大量地不足，如果你遇到什么问题，欢迎在 GitHub 提出
issue：<a href="https://github.com/unit-mesh/auto-dev" target="_blank" rel="noopener noreferrer">https://github.com/unit-mesh/auto-dev</a> 。</p></div><footer class="row docusaurus-mt-lg"></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/autodev-1-0-0">AutoDev 1.0 发布，全流程 AI 辅助编程</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-08-06T00:00:00.000Z">2023年8月6日</time> · <!-- -->阅读需 10 分钟</div></header><div class="markdown"><p>四月，在那篇《<strong>AutoDev：AI 突破研发效能，探索平台工程新机遇》</strong>，我们初步拟定了 AI 对于研发的影响。我们有了几个基本的假设：</p>
<ul>
<li>中大型企业将<strong>至少拥有一个</strong>私有化的大语言模型。</li>
<li>只有构建端到端工具才能借助 AI 实现增质提效。</li>
</ul>
<p>围绕于这些假设，我们开始构建 AutoDev，将并将它开源。也在我的博客里，写下开发中的所有心得，以期望能帮助到国内的企业构建自己的
AI 辅助编程能力。</p>
<p>作为一个开源项目，还是先上 GitHub 地址：<a href="https://github.com/unit-mesh/auto-dev" target="_blank" rel="noopener noreferrer">https://github.com/unit-mesh/auto-dev</a> 。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="围绕开发者体验设计三种辅助模式">围绕开发者体验，设计三种辅助模式<a href="#围绕开发者体验设计三种辅助模式" class="hash-link" aria-label="围绕开发者体验，设计三种辅助模式的直接链接" title="围绕开发者体验，设计三种辅助模式的直接链接">​</a></h2>
<p>起初，我并没有一个明确的开发蓝图。作为一个天天写代码的、所谓的专家级程序员，我是看我缺什么功能便写什么功能。</p>
<p>随后，围绕于所有的功能，我将其总结为三种辅助模式：</p>
<ul>
<li>聊天模式</li>
<li>Copilot 模式</li>
<li>补全模式</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="自动模式规范化的代码生成">自动模式：规范化的代码生成<a href="#自动模式规范化的代码生成" class="hash-link" aria-label="自动模式：规范化的代码生成的直接链接" title="自动模式：规范化的代码生成的直接链接">​</a></h3>
<p>触发方式：自动模式都在 Context Actions 下，即与上下文相关的 actions。方式自然是那个那能的快捷键：<strong>⌥⏎</strong> (macOS) 或者 *
<em>Alt+Enter</em>* (Windows/Linux)。</p>
<p>设计的初衷是：类似于我们在先前设计 ClickPrompt 时的一键模式。而代码并不是像网的各种炫酷的
demo，你需要考虑团队已有的软件规范和约定，否则生成的代码依旧是不可用的。于是，围绕于可配置，以及一些隐性知识的场景，我们构建了三个体现
AutoDev 的 auto 的场景：</p>
<ul>
<li>自动 CRUD。读取需求系统的需求，由一个手动编码的 agent，来不断进行交互。寻找合适的 controller，修改方法，添加新的方法等等。当前支持
Kotlin、JavaScript 语言。</li>
<li>自动生成测试。根据选定的类、方法，一键生成测试，并自动运行（在 RunConfiguration 合适的情况下）。当前支持
JavaScript、Kotlin、Java 语言。</li>
<li>自动代码补全。根据光标位置，自动进行代码填充。由于精力不够，在不同语言能力有些差异，在 Java 语言下，会结合读取<strong>代码规范</strong>；在
Kotlin、Java 语言会根据参数、返回值自动添加类作为上下文；在其它语言下，会通过“类似”（不要问是不是抄的）于 GitHub
Copilot、JetBrains AI Assistant 的相似度算法进行计算。</li>
</ul>
<p>每个自动模式都包含了一系列的<strong>自动上下文</strong>工作。如下图为<strong>可见的</strong>、自动代码补全的上下文示例：</p>
<p><img decoding="async" loading="lazy" src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4896c2bb-7356-4d15-a7d8-344e61b7b8db/Untitled.png" alt="Untitled" class="img_ev3q"></p>
<p>在这个上下文里，结合了一些配置好的规范，以及 BlogController 类相关的 field、parameters、return type，诸如 BlogService 等。</p>
<p>除此，还有一些隐藏的上下文，诸如于，我们在 AutoDev 配置中声名的语言：</p>
<div class="language-kotlin codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-kotlin codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">You MUST Use 中文 </span><span class="token keyword" style="color:#00009f">to</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> your answer </span><span class="token operator" style="color:#393A34">!</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>所以，其实吧，因为只有这么两个 “中文”，目测有大概 50% 的机率不会触发，我在考虑要不要重复三遍。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="伴随模式围绕日常体验设计">伴随模式：围绕日常体验设计<a href="#伴随模式围绕日常体验设计" class="hash-link" aria-label="伴随模式：围绕日常体验设计的直接链接" title="伴随模式：围绕日常体验设计的直接链接">​</a></h3>
<p>在设计伴随模式时，除了围绕于自己的需求设计，还调研、参考了一系列现有工具的实现，诸如于 AI Commit 等等。</p>
<p>由于，伴随模式都需要等待 LLM 返回结果，所以就都扔到 <code>AutoDev Chat</code> 模式下了。</p>
<p>不过，我现在发现了在 JetBrains AI Assistant 出来之后，它成了 AutoDev 的最大竞争对手，当然也是参考对象。诸如于，下图的 Explain
with AI、Explain error message with AI 的体验就做得很好。在这一点上，确实有待我进一步学习的。</p>
<p>像 AutoDev，你只能选中，然后再 Fix This。</p>
<p>除了上述的功能，你还可以用 AutoDev 来：</p>
<ul>
<li>生成提交信息</li>
<li>生成 release note</li>
<li>解释代码</li>
<li>重构代码</li>
<li>…………</li>
</ul>
<p>总之，别人有的，AutoDev 都可以有，还可以让你直接 create DDL。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="聊天模式一个边缘的功能">聊天模式：一个边缘的功能<a href="#聊天模式一个边缘的功能" class="hash-link" aria-label="聊天模式：一个边缘的功能的直接链接" title="聊天模式：一个边缘的功能的直接链接">​</a></h3>
<p>在腾出了时间之后，我们重新设计（其实是借鉴了 JetBrains，谁让他不支持广大的中国区用户）了 AutoDev 的 UI，并且支持一键 Chat
的方式，如图一中的 Context Actions。</p>
<p>你可以在这里和它聊天。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="llm-as-copilot-的思考">LLM as Copilot 的思考<a href="#llm-as-copilot-的思考" class="hash-link" aria-label="LLM as Copilot 的思考的直接链接" title="LLM as Copilot 的思考的直接链接">​</a></h2>
<p>对于现阶段来说，LLM 是一个 Copilot。它不会不改变软件工程的专业分工，但增强每个专业技术，基于AI的研发工具平台辅助工程师完成任务，影响个体工作。</p>
<p>它应该<strong>解决“我懒得做”及“我重复做”的事儿</strong>，诸如于写单元测试、编写代码、解决 issue、提交代码等等。作为一个程序员，我们应该多挖一些坑，多做一些有创造性的设计。</p>
<p>在 AutoDev 里，我们关注的是：AI 如何更好地辅助人类完成工作，并且它应该是伴随在工程师的 IDE 旅程上，尽可能让工程师不离开 IDE
就可以工作。</p>
<p>而对于 LLM as Copilot 这一理念来说，越来越多的工具将完善一点。</p>
<p>作为一个资深的 AI 应用工程师，我们正在思考 <strong>LLM as Co-Integrator</strong> 将如何真正的提升效能。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="faq">FAQ<a href="#faq" class="hash-link" aria-label="FAQ的直接链接" title="FAQ的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何接入国产私有化-llm-">如何接入国产、私有化 LLM ？<a href="#如何接入国产私有化-llm-" class="hash-link" aria-label="如何接入国产、私有化 LLM ？的直接链接" title="如何接入国产、私有化 LLM ？的直接链接">​</a></h3>
<p>在项目的源码里，我们提供了一个 Custom LLM Server 的 Python 接口示例，需要将接口转为 AutoDev 所能接受的。由于精力有限，我只测试过公司内部部署的
ChatGLM2，所以接口并不是很完善。如果大家有其它需要，可以来 GitHub issue 讨论。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么只有-intellij-版本">为什么只有 Intellij 版本？<a href="#为什么只有-intellij-版本" class="hash-link" aria-label="为什么只有 Intellij 版本？的直接链接" title="为什么只有 Intellij 版本？的直接链接">​</a></h3>
<p>作为一个开发过新的语言插件、深入过 Intellij Community、Android Studio 源码，并且优化过 Harmony OS IDE 架构的人，我真的只擅长
JetBrains IDE 的开发。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么时候会有-vs-code-版">什么时候会有 VS Code 版？<a href="#什么时候会有-vs-code-版" class="hash-link" aria-label="什么时候会有 VS Code 版？的直接链接" title="什么时候会有 VS Code 版？的直接链接">​</a></h3>
<p>简单来说：短期内不会有。</p>
<p>虽然，我也认真研究过 VS Code、X Editor 等编辑器的源码，但是兄弟姐妹们，VS Code 只是一个编辑器，不是一个 IDE
啊，它缺少太多的接口了。而如果只是简单的功能，现有的开源版本已经有很好的实现了。</p>
<p>除了上面的原因，还有：</p>
<p>其一：集成度低，开发困难。方式 1：VS Code 的 Tokenization 引擎是基于 TextMate 语法，那由 ****Oniguruma 结合又长又臭的正则表达式实现，非常不
靠谱；方式 2：基于 LSP 引擎，据我先前所试的，远景很美好。</p>
<p>其二：没有可供参考的代码和实现样板。如我们的 README 所提及：JetBrain plugin development is no walk in the park! Oops, we
cheekily borrowed some code from the GitHub Copilot, JetBrains Community version and the super cool JetBrains AI
Assistant plugin in our codebase. But fret not, we are working our magic to clean it up diligently!</p>
<p>所以，理想的方式是像 GitHub Copilot 一样，开发一套 IDE 无关的 Agent 机制，结合 TreeSitter 来实现编程语言相关的处理。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="其它">其它<a href="#其它" class="hash-link" aria-label="其它的直接链接" title="其它的直接链接">​</a></h2>
<p>AutoDev 的思想是将 LLM（Large Language Model）作为辅助开发者的 Copilot，通过提供辅助工具来解决一些繁琐的任务，让工程师能够更专注于有创造性的设计和思考。</p></div><footer class="row docusaurus-mt-lg"></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/blog/autodev-0-7-0">AutoDev 0.7.0 - 生成规范化代码，深入开发者日常</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-07-23T00:00:00.000Z">2023年7月23日</time> · <!-- -->阅读需 10 分钟</div></header><div class="markdown"><p>几个月前，我们朝着探索：**如何结合 AIGC 的研发效能提升的目标？**开源了 AutoDev，如 GitHub 所介绍的：</p>
<blockquote>
<p>AutoDev 是一款基于 JetBrains IDE 的 LLM/AI 辅助编程插件。AutoDev 能够与您的需求管理系统（例如 Jira、Trello、Github Issue 等）直接对接。在 IDE 中，您只需简单点击，AutoDev 会根据您的需求自动为您生成代码。您所需做的，仅仅是对生成的代码进行质量检查。</p>
</blockquote>
<p>随着，我们对于 LLM 能力边界的探索，发现了一些更有意思的模式，这些探索的模式也融入了 AutoDev 中。</p>
<p>PS：在 JetBrains 插件中搜索 <code>AutoDev</code> 并安装，配置上你的 LLM，如 OpenAI 及其智能体、开源 LLM 等即可使用。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="why-autodev对于-genai--软件研发结合的理解">WHY AutoDev？对于 GenAI + 软件研发结合的理解<a href="#why-autodev对于-genai--软件研发结合的理解" class="hash-link" aria-label="WHY AutoDev？对于 GenAI + 软件研发结合的理解的直接链接" title="WHY AutoDev？对于 GenAI + 软件研发结合的理解的直接链接">​</a></h2>
<p>于生成式 AI 来说，我们依旧保持先前分享时相似的观点：</p>
<ol>
<li>GenAI 可以在研发流程的几乎每个环节产生提效作用。</li>
<li>对于标准化流程提效比较明显，不规范的小团队提升有限。</li>
<li>由于  prompt 编写需要耗费时间，提效需要落地到工具上。</li>
</ol>
<p>所以，在设计 AutoDev 时，我们的目标是：</p>
<ol>
<li>端到端集成，降低交互成本。即从 prompt 编写到与 LLM 交互，再复制回工具中。</li>
<li>自动收集 prompt 的上下文生成内容、代码</li>
<li>最后由人来修复 AI 生成的代码。</li>
</ol>
<p>那么，手动整理规范、自动收集上下文，以提升生成内容的质量，便是我们做工具里所要探索的。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="autodev-07-新特性">AutoDev 0.7 新特性<a href="#autodev-07-新特性" class="hash-link" aria-label="AutoDev 0.7 新特性的直接链接" title="AutoDev 0.7 新特性的直接链接">​</a></h2>
<p>从四月份的大 DEMO，到如今的新版本里，我们持续研究了 GitHub Copilot、JetBrains AI Assistant、Cursor、Bloop 等 IDE/编辑器的代码、实现逻辑等。每个工具都有其独特的卖点，再结合我日常的一引起开发习惯，添加了一系列探索性的新功能。</p>
<p>详细见 GitHub：<a href="https://github.com/unit-mesh/auto-dev" target="_blank" rel="noopener noreferrer">https://github.com/unit-mesh/auto-dev</a></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="特性-1架构规范与代码规范内建">特性 1：架构规范与<strong>代码规范内建</strong><a href="#特性-1架构规范与代码规范内建" class="hash-link" aria-label="特性-1架构规范与代码规范内建的直接链接" title="特性-1架构规范与代码规范内建的直接链接">​</a></h3>
<p>LLM 的复读机模式（生成机机制），会根据当前上下文的编程习惯，复读出相似的代码。即在使用诸如 GitHub Copilot 这一类的 AI 代码生成功能时，它会根据我们如何处理 API，来生成新的 API 代码。如果我们的代码使用了 Swagger 注解生成 API 代码，那么在同一个 Controller 下也会生成相似的代码。</p>
<p>这也意味着问题：如果前人写的代码是不规范的，那么生成的代码亦是不规范的。因此，我们在 AutoDev 添加了配置 CRUD 模板代码的规范：</p>
<div class="language-json codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-json codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token property" style="color:#36acaa">&quot;spec&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;controller&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;- 在 Controller 中使用 BeanUtils.copyProperties 进行 DTO 转换 Entity&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;service&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;- Service 层应该使用构造函数注入或者 setter 注入，不要使用 @Autowired 注解注入。&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;entity&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;- Entity 类应该使用 JPA 注解进行数据库映射&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;repository&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;- Repository 接口应该继承 JpaRepository 接口，以获得基本的 CRUD 操作&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;ddl&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;-  字段应该使用 NOT NULL 约束，确保数据的完整性&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在一些特殊的场景下，只有这个规范是不够的，还需要配置示例代码。在有了这个配置之后，当我们在生成 Controller、Service 等代码时，可以直接用上述的规范生成。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="特性-2深入开发者日常编程活动">特性 2：深入开发者日常编程活动<a href="#特性-2深入开发者日常编程活动" class="hash-link" aria-label="特性 2：深入开发者日常编程活动的直接链接" title="特性 2：深入开发者日常编程活动的直接链接">​</a></h3>
<p>在四月份发布的时候 ，AutoDev 集成了基本的编程活动能力：AI 填充代码、添加代码注释、重构代码、解释代码等等。</p>
<p>而在开发 AutoDev 自身功能的时候，我们发现了一些更有意思的需求，也集成到了 IDE 中。</p>
<ul>
<li>一键生成提交信息。在我们使用 IDEA 的 UI 功能写提交信息时，可以一键生成参考的提交信息。</li>
<li>一键生成发布日志。在提交历史中，选中多个 commit，根据提交信息，来生成 CHANGELOG。</li>
<li>错误信息一键分析。编写代码时，DEBUG 遇到错误，选中错误信息，可以自动结合错误代码，发送给 LLM 进行分析。</li>
<li>代码测试代码。</li>
</ul>
<p>再加上，AutoDev 最擅长的拉取需求进行自动 CRUD 的功能，在功能上更加完备了。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="特性-3多语言的-ai-辅助支持">特性 3：<strong>多语言的 AI 辅助支持</strong><a href="#特性-3多语言的-ai-辅助支持" class="hash-link" aria-label="特性-3多语言的-ai-辅助支持的直接链接" title="特性-3多语言的-ai-辅助支持的直接链接">​</a></h3>
<p>四月份，我们发现 LLM 非常擅长于 CRUD，所以选中了 Java 语言作为测试与场景，只构建了 Java 语言的自动 CRUD 功能。而像我最近几年经常用的 Kotlin、Rust、TypeScript，都没有支持，而这就对我不友好了。</p>
<p>于是，参考了 Intellij Rust 的模块化结构，重新组织了分层、模块，并以 Intellij Plugin 的扩展点 （XML + Java）重塑了整个应用的基础架构。</p>
<p>以下围绕新架构下产生的新扩展点：</p>
<ul>
<li>语言数据结构扩展点。原先的设计中，这部分用于在 token 不够时，使用 UML 来表达原来的代码。随后，我们参考（抄袭）了 JetBrains AI Assistant 的语言扩展点功能，即不同的语言的数据结构在自身的扩展中实现。</li>
<li>语言 prompt 扩展点。不同语言也有自身的 prompt 差异，这些差异也被移到各自的模块中实现。</li>
<li>自定义 CRUD 工作流。现有的 CRUD 实现，绑定的是 Java 语言特性，而每个语言有自身的不同实现方式，也交由语言自身去实现。</li>
</ul>
<p>当然了，当前依旧只有 Java/Kotlin 支持是最好的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="特征-4更广泛的-llm-支持">特征 4：更广泛的 LLM 支持<a href="#特征-4更广泛的-llm-支持" class="hash-link" aria-label="特征 4：更广泛的 LLM 支持的直接链接" title="特征 4：更广泛的 LLM 支持的直接链接">​</a></h3>
<p>AutoDev 在设计初衷面向我们的第二个假设是：每个大公司都会推出自己的 LLM。每个 LLM 都有自身的特点，所以我们需要有更多的 LLM 支持。</p>
<ul>
<li>OpenAI 及其智能体。目前是测试最多的，也是最完整的。</li>
<li>Azure OpenAI。作为一个在国内合法使用 OpenAI 的渠道，我们也在先前的版本中进行了初步的支持，并逐步地完善了这个功能。</li>
<li>其它 LLM。虽然，还没有找到合适的国内 LLM API 进行适配，但是已经在接口上构建了这样的能力。</li>
</ul>
<p>欢迎大家结合自己的 LLM 尝试。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="特征-5更智能的-prompt-策略">特征 5：更智能的 prompt 策略<a href="#特征-5更智能的-prompt-策略" class="hash-link" aria-label="特征 5：更智能的 prompt 策略的直接链接" title="特征 5：更智能的 prompt 策略的直接链接">​</a></h3>
<p>回到我们 5 月份的那篇《**<a href="https://www.phodal.com/blog/llm-context-engineering/" target="_blank" rel="noopener noreferrer">上下文工程：基于 Github Copilot 的实时能力分析与思考</a>》**里，我们详细分析了 GitHub Copilot 的 prompt 策略。围绕于这个策略，会有基本的 promptElements 诸如：<code>BeforeCursor</code>, <code>AfterCursor</code>, <code>SimilarFile</code>, <code>ImportedFile</code>, <code>LanguageMarker</code>, <code>PathMarker</code>, <code>RetrievalSnippet</code> 等。</p>
<p>在发现了 JetBrains AI Assistant 也在尝试使用类似的方式来构建其 prompt 策略时。我们也进一步参考，并完善了 AutoDev 的 prompt 策略，以让其更智能。</p>
<ul>
<li>代码上下文策略。<!-- -->
<ul>
<li>Java 语言 + CRUD 模式下，会尝试按相关代码（BeforeCursor）、调用代码的所有方法、调用代码行、相关代码的 UML 等方式构建。</li>
<li>Java 语言其它模式下，会使用 DtModel 来构建类 UML 的注释，作为相关任务的参考。</li>
<li>Python 语言，会根据 import 来相似代码段来构建生成 prompt 作为注释，作为 LLM 的参考。</li>
</ul>
</li>
<li>计算策略。剩下的则是根据 token 是否超限，来不分配适合的上下文。</li>
</ul>
<p>作为一个所谓的 “智能上下文” 策略，现有的策略还需要进一步优化。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="其它">其它<a href="#其它" class="hash-link" aria-label="其它的直接链接" title="其它的直接链接">​</a></h2>
<p>有兴趣的话，欢迎来 GitHub 讨论代码：<a href="https://github.com/unit-mesh/auto-dev" target="_blank" rel="noopener noreferrer">https://github.com/unit-mesh/auto-dev</a> 。</p></div><footer class="row docusaurus-mt-lg"></footer></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog"><div class="pagination-nav__label">较新的博文</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">文档</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/intro">教程</a></li></ul></div><div class="col footer__col"><div class="footer__title">博客</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">博客</a></li></ul></div><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/unit-mesh/auto-dev" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">版权所有 © ${new Date().getFullYear()} Unit Mesh. 使用 Docusaurus 构建。</div></div></div></footer></div>
</body>
</html>